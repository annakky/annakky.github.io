{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\n## 정보의 저장\r\n\r\n### - 16진수\r\n\r\n1바이트는 8비트로 이루어져 이다. 1바이트는 이진수로 표현하면 00000000<sub>2</sub> 에서 11111111<sub>2</sub> 까지의 범위의 값을 갖는다.\r\n십진수로 표현하면 0<sub>10</sub> 에서 255<sub>10</sub> 의 범위를 갖는데, 이진수로 표현하기에는 너무 장황하고, 십진수로 표현하기에는 매번 변환을 해야한다.\r\n그래서 2진수로 변환이 쉽고, 표현하는데 어려움이 없는 16진수로 표현하여, 하나의 바이트 값은 00<sub>16</sub> 에서 FF<sub>16</sub> 까지의 범위를 갖는다.  \r\n\r\nC언어에서는 16진수를 표현하기 위해, 앞에 '0x' 혹은 '0X'를 사용한다. 또한 문자는 소문자, 대문자 구별없이 사용 가능하다. 예를 들어, 0xF4B12D 로 나타낼 수 있다. 앞으로 16진수를 표기하는데 있어 C언어의 표기법을 사용하겠다.  \r\n\r\n|진수|||||||\r\n|:---|---:|------:|------:|------:|------:|------:|\r\n|Binary|0001|0111|0011|1010|0100|1100|\r\n|Hexadecimal|    1|    7|    3|    A|    4|    C|\r\n\r\n위 예제처럼, 이진수가 주어지면, 4비트씩 나누어 16진수로 변환하면 된다.\r\n\r\n<br>\r\n\r\n### - 주소지정과 바이트 순서\r\n\r\n대부분의 컴퓨터에서 멀티 바이트 객체는 연속된 바이트에 저장되며, 객체의 주소는 사용된 바이트의 최소 주소로 정한다.\r\n예를 들어, int 타입의 변수 x가 주소 0x100라 하자. x는 4바이트의 공간을 가지므로, x는 메모리 주소 0x100, 0x101, 0x102, 0x103에 저장될 것이다.  \r\n\r\n여기서 x를 나타내는 비트를 [*x*<sub>*w - 1*</sub>, *x*<sub>*w - 2*</sub>, ... , *x*<sub>*1*</sub>, *x*<sub>*0*</sub>] 으로 *w*-비트 정수를 갖는다고 하자. 여기서 *x*<sub>*w - 1*</sub>은 가장 중요한 비트 (most significant bit)이고, *x*<sub>0</sub>은 가장 덜 중요한 비트이다. 예를 들면, 0x4F12AF 에서, 4는 가장 중요한 비트이고, F는 가장 덜 중요한 비트이다.  \r\n\r\n컴퓨터 타입에 따라 객체를 메모리에 저장하는 순서가 달라지는데, 어떤 컴퓨터는 가장 중요한 바이트부터 저장하고, 어떤 컴퓨터는 가장 덜 중요한 바이트부터 저장한다. 전자를 ***빅 엔디안***이라 하고, 후자를 ***리틀 엔디안***이라 부른다.  \r\n\r\nint형 변수 x가 주소 0x100에 있으며, 16진수 값 0x01234567을 갖는다고 하자.<br>\r\n\r\n**Big endian**\r\n\r\n||||||\r\n|:---:|:---:|:---:|:---:|:---:|\r\n|주소|<center>0x100</center>|<center>0x101</center>|<center>0x102</center>|<center>0x103</center>|\r\n|값|<center style=\"border-left: 1px solid lightgray; border-right: 1px solid lightgray\">01</center>|<center style=\"border-left: 1px solid lightgray; border-right: 1px solid lightgray\">23</center>|<center style=\"border-left: 1px solid lightgray; border-right: 1px solid lightgray\">45</center>|<center style=\"border-left: 1px solid lightgray; border-right: 1px solid lightgray\">67</center>|\r\n\r\n<br>\r\n\r\n**Little endian**\r\n\r\n||||||\r\n|:---:|:---:|:---:|:---:|:---:|\r\n|주소|<center>0x100</center>|<center>0x101</center>|<center>0x102</center>|<center>0x103</center>|\r\n|값|<center style=\"border-left: 1px solid lightgray; border-right: 1px solid lightgray\">67</center>|<center style=\"border-left: 1px solid lightgray; border-right: 1px solid lightgray\">45</center>|<center style=\"border-left: 1px solid lightgray; border-right: 1px solid lightgray\">23</center>|<center style=\"border-left: 1px solid lightgray; border-right: 1px solid lightgray\">01</center>|\r\n\r\n대부분의 프로그래머는 자신의 컴퓨터에서 사용되는 바이트 순서를 알 수 없기 때문에, 바이트 순서가 큰 문제가 되지 않는다. 그러나 바이트 순서가 이슈가 되기도 하는데, 이는 다른 컴퓨터로 이진 데이터를 전송할 때이다. 그러나 네트워크 표준을 통해 이러한 문제들을 해결하고 있다.\r\n\r\n<br>\r\n\r\n### - 쉬프트 연산\r\n\r\nC언어에서는 비트 패턴을 좌우로 이동시키는 *쉬프트*연산을 제공한다. 먼저, 좌측 쉬프트에 대해 알아보자.  \r\n\r\n좌측 쉬프트는 **x << k**로 표현하며, 비트 표시 [*x*<sub>*w - 1*</sub>, *x*<sub>*w - 2*</sub>, ... , *x*<sub>*1*</sub>, *x*<sub>*0*</sub>]를 [*x*<sub>*w - k - 1*</sub>, *x*<sub>*w - k - 2*</sub>, ... , *x*<sub>*1*</sub>, *x*<sub>*0*</sub>, 0, ... , 0]으로 만든다. 즉 좌측은 k비트만큼 밀려 삭제되며, 우측에는 k개의 0으로 채워진다.  \r\n\r\n우측 쉬프트는 좌측과 다르게 두 종류의 쉬프트를 제공한다.  \r\n\r\n> 논리 우측 쉬프트 : 좌측에 k개의 0으로 채워 [0, ... , 0, *x*<sub>*w - 1*</sub>, *x*<sub>*w - 2*</sub>, ..., *x*<sub>*k*</sub>]를 만든다.  <br><br>\r\n> 산술 우측 쉬프트 : 좌측에 k개를 가장 중요한 비트와 동일하게 채워 [*x*<sub>*w - 1*</sub>, ... , *x*<sub>*w - 1*</sub>, *x*<sub>*w - 1*</sub>, *x*<sub>*w - 2*</sub>, ... , *x*<sub>*k*</sub>]로 만든다.\r\n\r\nC언어에서는 어떤 타입의 우측 쉬프트가 사용되어야 하는지 명확하게 정의하고 있지 않지만, 일반적으로 부호형 데이터에서는 산술 쉬프트를, 비부호형 데이터에서는 논리 쉬프트를 사용한다.  \r\n\r\n|쉬프트 타입|Value 1|Value 2|\r\n|:---|:---:|:---:|\r\n|x|[00110011]|[11001100]|\r\n|x << 4|[0011***0000***]|[1100***0000***]|\r\n|x >> 4 (logical)|[***0000***0011]|[***0000***1100]|\r\n|x >> 4 (arithmetic)|[***0000***0011]|[***1111***1100]|\r\n\r\n<br>\r\n\r\n## 정수의 표시\r\n\r\n컴퓨터는 0, 1만을 사용하여 모든 수를 표현해야 한다. 그렇다면 어떻게 정수를 2진수를 사용하여 표현할 수 있을까. 음수를 0, 1만으로 어떻게 표현할 수 있을까. 에 대한 의문이 생기기 마련이다. 컴퓨터가 정수를 표현하는 방법을 소개하겠다.\r\n\r\n<br>\r\n\r\n### - 비부호형\r\n\r\n*w*비트의 정수형 데이터 타입이 있다고 하자. 이 정수는 [*x*<sub>*w - 1*</sub>, *x*<sub>*w - 2*</sub>, ..., *x*<sub>*0*</sub>]으로 표현된다. 비부호형은 unsigned로, 무조건 양수 혹은 0의 값만을 갖는다. 따라서 이 정수는 0 ~ 2<sup>*w*</sup> - 1 까지의 값을 갖는다.\r\n\r\n    7  -> [0111]  \r\n    14 -> [1110]\r\n\r\n<br>\r\n\r\n### - 2의 보수\r\n\r\n부호형 데이터를 알아보기 전에 먼저 알아야 할 것이 있다. 바로 2의 보수이다. 부호형 숫자를 컴퓨터에서 표시하는 가장 일반적인 방법이 **2의 보수**로 많이 알려져 있다. 2의 보수는 가장 높은 자리에서 자리 올림 발생 시 무시하므로 1의 보수보다 계산이 간단하다. 이러한 특성때문에 2의 보수를 사용한다.\r\n\r\n> 2의 보수란 어떤 수를 커다란 2의 제곱수에서 빼서 얻은 이진수이다. <sub>[[나무위키]](https://ko.wikipedia.org/wiki/2%EC%9D%98_%EB%B3%B4%EC%88%98)</sub>\r\n\r\n2의 보수를 쉽게 구하는 방법은, 모든 자리 수를 반전(0은 1로, 1은 0으로)한 뒤, 1을 더하면 된다. 아래 예를 통해 확인해보자.\r\n\r\n```\r\n7  -> [0111]\r\n-7 -> [1001]\r\n\r\n5  -> [0101]\r\n-3 -> [1101]\r\n5 - 3 = [10010] -> [0010] = 2\r\n```\r\n\r\n<br>\r\n\r\n### - 부호형\r\n\r\n*w*비트의 정수형 데이터 타입이 있다고 하자. 이 정수는 [*x*<sub>*w - 1*</sub>, *x*<sub>*w - 2*</sub>, ..., *x*<sub>*0*</sub>]으로 표현된다. 부호형 정수는 signed로 음의 값을 가질 수 있다. 따라서 이 정수는 -2<sup>*w - 1*</sup> ~ 2<sup>*w - 1*</sup> - 1 까지의 값을 갖는다.\r\n\r\n    7  -> [0111]  \r\n    -2 -> [1110]\r\n    7 + 7 -> [1110] = -2\r\n\r\n\r\n위 예제처럼, 부호형에서는 두 수를 더했을 때 값이 완전히 달라질 수 있음에 유의하여야한다.\r\n\r\n<br>\r\n\r\n### - 비부호형과 부호형간의 변환\r\n\r\nC는 비부호형과 부호형 간의 변환을 허용한다. 대부분의 시스템은 기본 비트 표시는 바뀌지 않는다는 규칙을 따른다. 따라서 변환시 값이 달라질 수 있음에 유의하여야한다. 아래 예시를 통해 확인해보자.\r\n\r\n|비트표현|비부호형|부호형|\r\n|:---:|:---:|:---:|\r\n|[0101]|5|5|\r\n|[1101]|13|-3|\r\n\r\n<br>\r\n\r\n### - 비트 확장\r\n\r\n값은 동일하게 유지한 채, 더 큰 길이의 자료형으로 변환하는 것은 언제나 가능해야한다. 비트 확장은 산술 우측 쉬프트와 비슷하다. 아래 예제는 빅 엔디안 머신에서 32비트 프로그램으로 실행한 결과이다.\r\n\r\n    short sx = -12345          : cf c7\r\n    int x = sx                 : ff ff cf c7\r\n\r\n    unsigned short usx = 53191 : cf c7\r\n    unsigned int ux = usx      : 00 00 cf c7\r\n\r\n위 예제처럼, 비부호형 정수의 경우 확장된 크기만큼 0을 왼쪽에 채운다. 부호형 정수의 경우는 확장된 크기만큼 가장 중요한 비트와 같은 값을 왼쪽에 채운다.\r\n\r\n<br>\r\n\r\n### - 숫자의 절삭\r\n\r\n이번에는 작은 길이의 자료형으로 변환하여, 비트의 개수를 줄이는 경우를 살펴보자.\r\n\r\n```c\r\nint x = 53191;\r\nshort sx = (short) x;             // -12345\r\n\r\nunsigned int a = 153191;\r\nunsigned short sa = (short) a;    // 22119\r\n```\r\n\r\n정수 x는 비트 [*x*<sub>*w - 1*</sub>, *x*<sub>*w - 2*</sub>, ..., *x*<sub>*0*</sub>]을 갖는다고 하자. 이 때 k개의 비트를 갖도록 절삭한 결과를 x'이라하면, x'은 [*x*<sub>*k - 1*</sub>, *x*<sub>*k - 2*</sub>, ..., *x*<sub>*0*</sub>]을 갖게 된다. k의 자리수를 갖도록 왼쪽의 값을 모두 제거한다고 생각하면 쉽다.  \r\n\r\n비부호형에서, x' = x mod 2<sup>k</sup>, 즉 x'은 x를 2의 k제곱으로 나눈 값과 같다. 부호형에서는 절삭 후 가장 중요한 비트를 부호비트로 바꾼다.  \r\n\r\n위 예제와 같이, 숫자의 절삭에서 오버플로우가 일어나 값이 바뀔 수 있다는 것에 유의하여야한다.  \r\n\r\n곱셈과 나눗셈, 특히 나눗셈은 덧셈과 비트 연산보다 훨씬 많은 시간을 필요로 한다. 따라서 ***'x * 15'*** 을 하는 것보다 ***'(x << 4) - x'*** 를 하는 것이 프로그램의 성능을 높일 수 있다. 다만 주의할 점은, 정수 연산시 오버플로우를 항상 고려하여 코드를 작성해야한다.\r\n\r\n<br>\r\n\r\n## 부동소수점\r\n\r\n> 부동소수점이란, 실수를 컴퓨터상에서 근사하여 표현할 때 소수점의 위치를 고정하지 않고 그 위치를 나타내는 수를 따로 적는 것이다. <sub>[<위키백과>](https://ko.wikipedia.org/wiki/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90)</sub>\r\n\r\n<br>\r\n\r\n정의를 보면 와닫지 않을 수 있다. 쉽게 설명하면 컴퓨터 상에서 실수를 표현하기 어려우니, 실수를 하나의 틀에 넣고 그 틀을 이진수로 표현하면 컴퓨터도 실수를 표현할 수 있다고 생각해서 사용한 것이 부동소수점이다. 그래도 이해하기 어려울 수 있다. 이해를 돕기 위해, 널리 쓰이는 표준인 IEEE 부동소수점을 가지고 설명하겠다.  \r\n\r\nIEEE 부동소수점 표준은 V = (-1)<sup>*s*</sup> X *M* X 2<sup>*E*</sup> 형태로 나타낸다.\r\n\r\n + 부호 ***s*** 는 실수가 음수인지(s = 1) 양수인지(s = 0) 결정한다.\r\n + 유효숫자 ***M*** 은 비율 이진수로 1과 2 - *ε* 사이 또는 0과 1 - *ε* 사이의 값을 갖는다.\r\n + 지수 ***E*** 는 2의 제곱으로 자리값을 제공한다.  \r\n\r\n 부동소수점 수의 비트 표시는 이 값을 인코딩하기 위해 세 개의 필드로 나눠진다.  \r\n\r\n+ 한 개의 부호 비트 ***s*** 는 부호 *s*를 직접 인코딩한다.\r\n+ k비트 지수 필드 ***exp*** = *e*<sub>*k - 1*</sub>...*e*<sub>*1*</sub>*e*<sub>*0*</sub>는 지수 *E*를 인코딩한다.\r\n+ n비트 비율 필드 ***frac*** = *f*<sub>*n - 1*</sub>...*f*<sub>*1*</sub>*f*<sub>*0*</sub>는 유효숫자 *M*을 인코딩한다.  \r\n\r\n32비트 시스템에서는 s = 1, k = 8, n = 23비트를 가지며, double형의 64비트를 갖는 자료형에서는 s = 1, k = 11, n = 52비트를 갖는다.\r\n\r\n쉽게 설명하면, 한 실수를 IEEE 부동소수점 표준에 맞게 변환한 다음, 각 필드에 맞게 인코딩하면 된다는 뜻이다.  \r\n\r\n부동소수점으로 나타낼 수 있는 값을 크게 세 분류로 나눌 수 있다. 그 중 가장 일반적인 경우를 ***정규화 값***이라고 한다.\r\n\r\n<br>\r\n\r\n### - 정규화 값\r\n\r\n정규화 값은 가장 일반적인 경우로, exp 비트 패턴이 모두 0이 아니며, 모두 1이 아닌 경우이다. 여기서 **지수부 필드**는 부호형 정수로 만들기 위해 ***Bias*** 를 사용하였다. Bias는 *Bias* = 2<sup>*k - 1*</sup> - 1 이며, 지수부의 음수 표현을 위해 사용된다.(단일정밀도에서 127, 이중정밀도에서 1023) 즉 지수부를 비부호형으로 계산한 다음, Bias를 빼주면 원하는 지수값을 얻을 수 있다는 것이다.\r\n\r\n따라서 지수 값은 *E* = *e* - *Bias*이며, e는 비트 패턴 *e*<sub>*k - 1</sub> ... *e*<sub>*1*</sub> *e*<sub>*0*</sub> 을 가진다.  \r\n\r\n**비율**필드 frac은 이진수 표시로 0.*f*<sub>*n - 1*</sub> ... *f*<sub>*1*</sub> *f*<sub>*0*</sub> 를 가지는 것으로 해석된다. **유효숫자** M = 1 + *f* 로 frac에 암시적으로 정수부분에 1이 있다고 본다. 이는 E를 조정해서 유효숫자 M이 항상 1 ≤ M < 2 범위를 갖도록 할 수 있기 때문에, 비트 한개를 무료로 얻어 정밀도를 높히기 위함이다.\r\n\r\n<br>\r\n\r\n### - 비정규화 값\r\n\r\n비정규화 값은 지수 필드가 모두 0일때를 말한다. 이 경우 ***지수 값***은 *E* = 1 - *Bias* 이다. ***유효숫자*** M = *f* 로, 암시적으로 정수부분에 1이 아닌, 0이 있는 것이다.  \r\n\r\n여기서 눈치가 빠른 사람들은 궁금할 것이다. 왜 지수 값이 -*Bias*가 아닌 1 - *Bias*를 사용했을까? 왜 유효숫자 정수 부분은 0인가?  \r\n\r\n먼저 간단한 유효숫자에 대해 설명해주겠다. 기존 정규화 값으로는 0을 표현할 수가 없다. 따라서 0을 표현하기 위해 지수 필드가 모드 0인 매우 작은수의 경우 정수 부분을 0으로 설정하여 0을 표현할 수 있도록 하였다. 또한 비정규화 숫자들의 기능은 0.0에 매우 가까운 값들을 나타내기 위함이기 때문에 정수 부분을 0으로 설정한 것이다.  \r\n\r\n그렇다면 지수 값은 왜 1 - *Bias*인가? 이는 비정규화 값에서 정규화 값으로 전환함에 있어 편리하기 때문이다. 아래 예시로 확인해보자.\r\n\r\n`0 00000000 000000000000000000001` = 0.000000000000000000001 * 2<sup>-126</sup>  \r\n`0 00000000 111111111111111111111` = 0.111111111111111111111 * 2<sup>-126</sup>\r\n`0 00000001 000000000000000000000` = 1.000000000000000000000 * 2<sup>-126</sup>\r\n\r\n위 2개 수는 비정규화 값이고, 맨 아래는 정규화 값이다. **비트 수준에서**, 위 2개 값을 더했을 때, 맨 아래 값이 나오면 비트 연산에도 추가적인 계산 없이 비트 덧셈만 진행하면 된다. 이는 매우 편리하기 때문에 이에 맞게 실제 값도 조정하고 싶을 것이다. 따라서 지수 값을 1 - *Bias*로 조정함으로써, 비정규화 값과 정규화 값 전환이 편리하도록 만든 것이다.\r\n\r\n<br>\r\n\r\n### - 특수 값\r\n\r\n부동소수점의 마지막 범주는 지수 필드가 모두 1인 경우이다. 지수 필드가 모두 1이고, 비율 필드가 모두 0이면 결과값은 무한대를 나타낸다. 즉 *s* = 0 이면 +∞ , *s* = 1 이면 -∞ 를 의미한다. 또한 비율 필드가 모두 0이 아니면, 결과값은 *NaN* 으로, \"not a number\"를 의미한다. 이런 값들은 \r\n∞ - ∞ 혹은 (-1)<sup>0.5</sup> 같은 연산의 결과로 반환된다. 이들은 초기화되지 않은 데이터를 표시할 때와 같이 일부 응용에서 유용할 수 있다.\r\n\r\n아래 예제를 통해 부동소수점에 대해 정리해보자. 지수비트 *k* = 4, 비율비트 *n* = 3, *Bias* = 2<sup>4 - 1</sup> - 1 = 7 을 갖는 8비트 부동소수점 형식으로 나타낼 수 있는 수를 표로 정리하였다.\r\n\r\n|설명|비트 표현|*E*|*M*|2<sup>*E*</sup>X*M*|십진수|\r\n|---|---|---|---|---|---|---|\r\n|0|0 0000 000|-6|0/8|0/512|0.0|\r\n|가장 작은 양수|0 0000 001|-6|1/8|1/512|0.001953|\r\n||0 0000 010|-6|2/8|2/512|0.003906|\r\n|||. . .||||\r\n|가장 큰 비정규화|0 0000 111|-6|7/8|7/512|0.013672|\r\n|가장 작은 정규화|0 0001 000|-6|8/8|8/512|0.015625|\r\n||0 0001 001|-6|9/8|9/512|0.017578|\r\n|||. . .||||\r\n||0 0110 111|-1|15/8|15/16|0.9375|\r\n|1|0 0111 000|0|8/8|1|1.0|\r\n||0 0111 001|0|9/8|9/8|1.125|\r\n|||. . .||||\r\n|가장 큰 정규화|0 1110 111|7|15/8|1920/8|240.0|\r\n|무한대|0 1111 000|-|-|-|∞|\r\n|*NaN*|0 1111 001|-|-|-|-|\r\n\r\n정규화 값, 비정규화 값의 *Bias* 를 고려하며 값을 확인하다보면 어느새 부동소수점에 익숙해져 있을 것이다.\r\n\r\n> 부동소수점은 제한된 범위와 정밀도를 갖기 때문에, 실제 값의 근사값으로 연산을 진행한다. 따라서 오차가 생길 수 있음을 항상 유의하여야한다.\r\n\r\n<br>\r\n\r\n### - 비트 확장 / 축소\r\n\r\nfloat, double은 마찬가지로 확장되거나 축소될 수 있다. int, float, double 간의 타입 캐스팅이 일어났을 때, 어떤 변화가 일어나는지 확인해보자.\r\n\r\n+ int에서 float로, 숫자는 오버플로우할 수 없지만, 근사될 수 있다.\r\n+ int나 float에서 double로, 정확한 수치는 보존될 수 있다.(더 넓은 범위의 비트를 갖기 때문에 표현 가능한 값의 범위가 늘어나 정밀도가 더 크기 때문)\r\n+ double에서 float로, 범위가 더 작아지기 때문에 오버플로우하여 +∞ 혹은 -∞ 가 될 수 있다. 그 이외의 경우 정밀도가 더 작아져 근사될 수 있다.\r\n+ float나 double에서 int로, 값은 0 방향으로 근사될 것이다.(소수점 이하 버림)\r\n\r\n<br>\r\n\r\n이번 포스트에서는 정수와 실수의 표현 방법을 알아보았다. C에서 예상치 못한 결과나 버그를 마주칠때가 있는데, 위 내용을 잘 이해하면 그런 문제들을 해결하는데 도움이 될 것이다. 다음 포스트에서는 프로그램의 기계 수준의 표현에 대해 설명하겠다.","excerpt":"정보의 저장 - 16진수 1바이트는 8비트로 이루어져 이다. 1바이트는 이진수로 표현하면 000000002 에서 111111112 까지의 범위의 값을 갖는다.\n십진수로 표현하면 010 에서 25510 의 범위를 갖는데, 이진수로 표현하기에는 너무 장…","fields":{"slug":"/computer-system-data/"},"frontmatter":{"date":"Dec 09, 2020","title":"정보의 표현과 처리","tags":["Computer System"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n## 예외처리\r\n\r\n예외처리는 프로그램의 예상치 못한 종료나, 치명적인 오류를 예방할 수 있는 방법 중 하나이다. 따라서 꼼꼼하게 예외처리를 해 주는 것이 굉장이 중요하다고 할 수 있다. 이에 사용되는 것이 **try-except-else(finally)** 문이다.\r\n\r\n|이름|설명|\r\n|:---:|---|\r\n|try:|예외 처리를 할 부분|\r\n|except:|예외가 발생했을 때 실행할 코드|\r\n|else:|예외가 발생하지 않았을 때 실행할 코드|\r\n|finally:|예외 발생 여부와 상관없이 실행할 코드|\r\n\r\n위 표에서 볼 수 있듯이, 예외 처리를 할 코드를 try 문에 넣은 뒤, 예외 발생 여부에 따른 코드를 알맞게 사용하면 된다. 아래 예시로 자세히 살펴보자.\r\n\r\n```python\r\nnum1, num2 = input(\"나눗셈을 할 숫자를 2개 넣어주세요: \").split()\r\ntry:\r\n    result = int(num1) / int(num2)\r\nexcept ValueError:\r\n    print('오류 : 입력 값이 실수가 아닙니다.')\r\nexcept:\r\n    print('오류 발생')\r\nelse:\r\n    print(\"결과:\", result)\r\nfinally:\r\n    print(\"프로그램 종료\")\r\n```\r\n\r\n<br>\r\n\r\n<span style=\"color: skyblue;\">실행 결과</span>\r\n\r\n```shell\r\n나눗셈을 할 숫자를 2개 넣어주세요: 10 2\r\n결과: 5.0\r\n프로그램 종료\r\n```\r\n\r\n```shell\r\n나눗셈을 할 숫자를 2개 넣어주세요: a b\r\n오류 : 입력 값이 실수가 아닙니다.\r\n프로그램 종료\r\n```\r\n\r\n```shell\r\n나눗셈을 할 숫자를 2개 넣어주세요: 10 0\r\n오류 발생\r\n프로그램 종료\r\n```\r\n\r\n위 예제처럼, except 뒤에 추가적으로 error type을 지정하여, 특정 에러일 경우를 핸들링할 수 있다.\r\n실행 결과를 보면, *'a, b'* 처럼 실수가 아닌 값을 입력하면, ValueError 이므로, **'except ValueError'** 가 실행된다.\r\n두번째 입력값에 0을 넣게 되면, *ZeroDivisionError*가 발생하여, **'except'** 가 실행된다.\r\nZeroDivisionError만 특별히 핸들링하고 싶다면, **'except ZeroDivisionError:'** 로 구성하면 된다.\r\n\r\n<br>\r\n\r\n## 클래스\r\n\r\n### - 초기화 메소드\r\n\r\n파이썬이 객체 지향 프로그래밍 언어인 것은 누구나 다 알 것이다. 그 OOL에 걸맞게 클래스를 잘 활용하기 위해, 클래스에 대해 자세히 아는 것이 중요하다. 객체는 정의될 때, 각 속성들을 초기화 및 할당해줘야한다. 마찬가지로 클래스도 마찬가지로 정의할 때 초기화를 해줘야하는데, 이 때 사용되는 것이 초기화 메소드, ***__init()__*** 이다. 아래 예제를 통해 자세히 확인해보자.\r\n\r\n```python\r\nclass Person:\r\n    def __init__(self, name, age):\r\n        self.name = name\r\n        self.age = age\r\n\r\n    def hi(self):\r\n        print(\"Hello!! My name is\", self.name, \"\\nI\\'m {} years old!\".format(self.age))\r\n\r\nminsoo = Person('MinSoo', 18)\r\nminsoo.hi()\r\n```\r\n\r\n```shell\r\nHello!! My name is MinSoo \r\nI'm 18 years old!\r\n```\r\n\r\n위 예제를 보면, 생성자의 첫 번째 매개변수는 **self** 로, 이는 생성한 인스턴스를 의미한다. 클래스 내에서는 인스턴스를 부를 방법이 없기 때문에 self를 사용한다.  \r\n\r\n<br>\r\n\r\n### - 문자열화 메소드\r\n\r\n이와 비슷한 메소드가 더 있다. [파이썬 기초 1](/python-basic_1/#--객체의-식별값)에서 확인할 수 있듯이, 모든 객체는 다른 객체와 구분되는 고유한 정보를 갖는데, 이를 **id** 라고 한다. 클래스 인스턴스도 객체이므로, id를 갖는다.\r\n\r\n```python\r\nprint(minsoo)\r\n```\r\n```shell\r\n<__main__.Person object at 0x0335F388>\r\n```\r\n\r\n'0x0335F388'가 바로 인스턴스의 아이디이다. 그러나 이를 통해 객체가 어떤 값을 가지고 있는지 알기 힘들다. 따라서 이를 도와주는 메소드가 바로 **__str__** 이다. 아래 예제로 자세히 살펴보자.\r\n\r\n```python\r\nclass Person:\r\n    def __init__(self, name, age):\r\n        self.name = name\r\n        self.age = age\r\n    \r\n    def __str__(self):\r\n        return ('Person(name = ' + self.name + ', age = ' + str(self.age) + ')')\r\n\r\n    def hi(self):\r\n        print(\"Hello!! My name is\", self.name, \"\\nI\\'m {} years old!\".format(self.age))\r\n\r\nminsoo = Person('MinSoo', 18)\r\nprint(minsoo)\r\n```\r\n\r\n```shell\r\nPerson(name = MinSoo, age = 18)\r\n```\r\n\r\n<br>\r\n\r\n### - 문서화 메소드\r\n\r\n파이썬에서 함수의 사용법과 같은, 함수에 대한 정보를 얻기 위해 help 함수를 종종 사용한다.\r\n이는 기존 내장 클래스, 함수에만 적용되는 것이 아닌, 사용자가 생성한 클래스에서도 가능하다.  \r\n\r\n<br>\r\n\r\n파이썬은 모듈, 함수, 클래스를 정의할 때, 기능에 관한 설명을 문자열로 작성하면 이를 **\\__doc__** 속성에 자동으로 할당한다.\r\n이를 잘 활용하면, 협업에 큰 도움이 될 것이다. 아래 예시를 통해 문서화된 정보를 조회하는 방법을 살펴보자.\r\n\r\n```python\r\nclass Student:\r\n    \"\"\"\r\n    학생 정보를 저장하기 위한 클래스\r\n    name : 학생 이름\r\n    printName() : 학생 이름 출력 함수\r\n    \"\"\"\r\n    def __init__(self, name):\r\n        self.name = name\r\n\r\n    def printName(self):\r\n        \"학생 이름을 출력하는 함수\"\r\n        print(self.name)\r\n\r\n\r\nhelp(Student)\r\n```\r\n\r\n```shell\r\nclass Student(builtins.object)\r\n |  Student(name)\r\n |  \r\n |  학생 정보를 저장하기 위한 클래스\r\n |  name : 학생 이름\r\n |  printName() : 학생 이름 출력 함수\r\n |  \r\n |  Methods defined here:\r\n |  \r\n |  __init__(self, name)\r\n |      Initialize self.  See help(type(self)) for accurate signature.\r\n |  \r\n |  printName(self)\r\n |      학생 이름을 출력하는 함수\r\n |  \r\n |  ----------------------------------------------------------------------\r\n |  Data descriptors defined here:\r\n |  \r\n |  __dict__\r\n |      dictionary for instance variables (if defined)\r\n |  \r\n |  __weakref__\r\n |      list of weak references to the object (if defined)\r\n```\r\n<br>\r\n\r\n클래스 뿐만 아니라, 클래스 내부 함수도 help를 사용할 수 있다.\r\n\r\n```python\r\nhelp(Student.printName)\r\nprint(Student.__doc__)\r\n```\r\n\r\n```shell\r\nprintName(self)\r\n    학생 이름을 출력하는 함수\r\n\r\n\r\n    학생 정보를 저장하기 위한 클래스\r\n    name : 학생 이름\r\n    printName() : 학생 이름 출력 함수\r\n```\r\n\r\n이를 잘 사용하면 함수를 사용할 때, 다시 함수를 찾아 확인하는 수고를 줄일 수 있고, 다른 사람의 코드를 사용할 때 편리해 협업에 효과적이다.\r\n\r\n<br>\r\n\r\n### - 캡슐화\r\n\r\n클래스를 사용하면서, 클래스 속성에 함부로 접근하지 못하도록 하고 싶을 수 있다. 단순히 [인스턴스 명].[속성명] 으로 쉽게 접근하면, 예상치 못하게 속성값이 변할 수 있기 때문이다. 따라서 이를 방지하기 위해 캡슐화를 하여 클래스를 만든다.\r\nJava와 C++에서는 private이라는 키워드를 통해서 접근 제한이 가능하지만, 파이썬은 제공하지 않는다. 따라서 변수 이름에 표시를 해, private 변수라는 것을 확인할 수 있도록 한다. 아래 예제를 통해 확인해보자.\r\n\r\n```python\r\nclass Person:\r\n    def __init__(self, name, age):\r\n        self._name = name\r\n        self._age = age\r\n\r\n    def get_name(self):\r\n        return self._name\r\n\r\n    def get_age(self):\r\n        return self._age\r\n\r\n    def set_age(self, age):\r\n        if age > 0:\r\n            self._age = age\r\n\r\nminsoo = Person('MinSoo', 18)\r\nprint(minsoo.get_name())\r\nminsoo.set_age(-5)\r\nprint(minsoo.get_age())\r\n```\r\n\r\n```shell\r\nMinSoo\r\n18\r\n```\r\n위 예제를 보면, 멤버변수에 ***__*** 혹은 ***_*** 로 시작하도록 하여 멤버 변수를 보호한다.\r\n이처럼, get_name(), get_age(), set_age()와 같은 멤버 함수만을 통하여 멤버변수로 접근할 수 있도록 한다.\r\n물론 'minsoo.\\__age'를 통해 접근할 수 있지만, 프로그래머들 사이에 약속을 한다면 private 변수와 같은 효과를 볼 수 있다.\r\n\r\n<br>\r\n\r\n### - 특수 메소드\r\n\r\n클래스를 만들어 사용하다보면, 인스턴스를 위한 연산, 혹은 함수를 사용하고 싶을 수 있다. 아래 예제를 통해 먼저 살펴보자.\r\n\r\n```python\r\nclass Vector:\r\n    def __init__(self, x, y):\r\n        self.x = x\r\n        self.y = y\r\n\r\n    def __str__(self):\r\n        return '({}, {})'.format(self.x, self.y)\r\n\r\n    def add(self, other):       # 덧셈 함수\r\n        return Vector(self.x + other.x, self.y + other.y)\r\n\r\nv1 = Vector(1, 1)\r\nv2 = Vector(2, 2)\r\n\r\nprint(v1.add(v2))\r\n```\r\n\r\n```shell\r\n(3, 3)\r\n```\r\n\r\n<br>\r\n\r\n클래스의 다른 인스턴스와의 상호작용을 하고 싶을 때는, 위와 같이 other를 사용하면 된다. 그러나 두 벡터의 합을 표현하는데 *add()* 는 직관적이지 않고, 사용하기 불편하다. 이렇게 덧셈과 뺄셈 연산자를 사용하기 위해서는 특수 메소드를 구현해야한다.\r\n\r\n```python\r\nclass Vector:\r\n    def __init__(self, x, y):\r\n        self.x = x\r\n        self.y = y\r\n\r\n    def __str__(self):\r\n        return '({}, {})'.format(self.x, self.y)\r\n\r\n    def __add__(self, other):       # '+' 연산자\r\n        return Vector(self.x + other.x, self.y + other.y)\r\n\r\n    def __sub__(self, other):       # '-' 연산자\r\n        return Vector(self.x - other.x, self.y - other.y)\r\n\r\nv1 = Vector(1, 1)\r\nv2 = Vector(2, 2)\r\n\r\nv3 = v1 + v2\r\nv4 = v1 - v2\r\n\r\nprint(v3)\r\nprint(v4)\r\n```\r\n\r\n```shell\r\n(3, 3)\r\n(-1, -1)\r\n```\r\n\r\n'+', '-' 외에 다른 산술 연산자 뿐만 아니라, 비교 연산자, 내장 함수들까지 특수 메소드로 구현할 수 있다. 내장 함수들은 종류가 많아 따로 정리하지는 않았다. *len()* 함수를 *\\__len__()* 처럼 특수 메소드로 구현할 수 있으니, 잘 응용하면 될 것이다. 산술 연산자와 비교 연산자를 표를 통해 정리해놓았다. 아래 표를 통해 확인해보자.\r\n\r\n  * 산술 연산자\r\n\r\n|연산자|특수 메소드|하는 일|\r\n|:---:|:------:|----------|\r\n|x + y|\\__add__(self, other)|x와 y의 합|\r\n|x - y|\\__sub__(self, other)|x와 y의 차|\r\n|x * y|\\__mul__(self, other)|x와 y의 곱|\r\n|x ** y|\\__pow__(self, other)|x의 y 거듭제곱|\r\n|x / y|\\__truediv__(self, other)|x를 y로 나눈 값|\r\n|X // y|\\__floordiv__(self, other)|x를 y로 나눈 몫|\r\n|x % y|\\__mod__(self, other)|x를 y로 나눈 나머지|\r\n|+x|\\__pos__(self)|x의 양수|\r\n|-x|\\__neg__(self)|x의 음수|\r\n\r\n<br>\r\n\r\n  * 비교 연산자\r\n\r\n|연산자|특수 메소드|하는 일|\r\n|:---:|:------:|----------|\r\n|x < y|\\__lt__(self, other)|x가 y보다 작은가|\r\n|x <= y|\\__le__(self, other)|x가 y보다 작거나 같은가|\r\n|x >= y|\\__ge__(self, other)|x가 y보다 크거나 같은가|\r\n|x > y|\\__gt__(self, other)|x가 y보다 큰가|\r\n|x == y|\\__eq__(self, other)|x와 y가 같은가|\r\n|X != y|\\__ne__(self, other)|x와 y가 다른가|\r\n\r\n<br>\r\n\r\n### - 클래스 변수\r\n\r\n클래스에서, 모든 인스턴스가 공통적으로 갖는 특징이 있을 수 있다. 예를 들면, 원에 대한 클래스를 지정하는데, 원주율(PI)는 모든 원이 같은 값을 가진다. 따라서 생성자를 통해 계속 원마다 초기화하는 것보다, 모든 인스턴스가 공통적으로 갖는 변수로 지정하는게 효율적이다. 이를 클래스 변수라고 한다. 아래 예제를 통해 확인해보자.\r\n\r\n```python\r\nclass Circle:\r\n    PI = 3.141592       # 클래스 변수\r\n    def __init__(self, name, radius):\r\n        self.__name = name\r\n        self.__radius = radius\r\n\r\n    def area(self):\r\n        return Circle.PI * self.__radius ** 2\r\n\r\nc1 = Circle('C1', 4)\r\nprint(c1.area())\r\nc2 = Circle('C2', 3)\r\nprint(c2.area())\r\n```\r\n\r\n```shell\r\n50.265472\r\n28.274328\r\n```\r\n\r\n> 단, 클래스 내부에서 클래스 변수를 사용할 때는, *Circle.PI* 로 사용하여야 한다.\r\n\r\n<br>\r\n\r\n## 람다 함수\r\n\r\n이전 포스트 [파이썬 기초 1](/python-basic_1/#루프-제어변수-익명화) 에서 익명화에 대해 잠깐 언급한 적이 있다.\r\n이와 비슷하게, 람다 함수는 이름이 없는 특성 때문에 익명 함수라고도 불린다.\r\n람다 함수는 어떨때 보통 사용할까? 함수를 만들고 싶지 않지만 함수화 된 기능을 사용하고 싶거나, 1회용으로 사용할 함수를 만들고 싶을 때 많이 사용한다.    \r\n<br>\r\n그렇다면, 굳이 람다 함수를 사용하는 이유가 무엇일까? 이는 바로, 람다 함수를 사용하면 축약된 표현으로 코드가 간결해지고, 메모리 공간을 별도로 할당하지 않기 때문에 메모리를 절약할 수 있다. 람다 함수는 사용된 후, 힙 메모리에서 사라지기 때문이다. 그럼 람다 함수의 사용법에 대해 살펴보자.\r\n\r\n```python\r\nlambda [매개변수] : {표현식}\r\n```\r\n\r\n이해를 돕기 위해 예제를 준비했다.\r\n아래 예제를 통해 람다 함수에 대해 살펴보자.\r\n\r\n```python\r\ndef add(x, y):          # add 함수\r\n    return x + y\r\n\r\nprint('100 + 200 =', add(100, 200))\r\n\r\nprint('100 + 200 =', (lambda x, y: x + y)(100, 200))            # 람다 함수\r\n```\r\n\r\n```shell\r\n100 + 200 = 300\r\n100 + 200 = 300\r\n```\r\n\r\n위 예제를 보면, 동일한 결과값이 나오는 것을 확인할 수 있다. 위 예제는 일반적으로 람다 함수를 사용하는 방법은 아니지만, 람다 함수에 대해 이해할 수 있는 예제라고 생각된다. 람다 함수는 필터 혹은 맵과 함께 자주 사용된다. 그럼 필터 함수가 무엇인지 살펴보겠다.\r\n\r\n<br>\r\n\r\n## 필터 함수\r\n\r\n필터 함수는, 리스트와 같은 반복 가능한 요소들을 함수에 넣어 참인 것만 묶어서 반환한다. 필터 함수의 문법은 다음과 같다.\r\n\r\n```python\r\nfilter([적용할 함수], [반복 가능 객체])\r\n```\r\n\r\n이해를 돕기 위해, 아래 예제를 확인해보자.\r\n\r\n```python\r\ndef filter_positive(n):\r\n    if n > 0:\r\n        return True\r\n    else:\r\n        return False\r\n\r\nnum_list = [-3, -2, -1, 0, 1, 2, 3]\r\nfor n in filter(filter_positive, num_list):\r\n    print(n, end = ' ')\r\n```\r\n\r\n```shell\r\n1 2 3 \r\n```\r\n\r\n만약 *filter_positive()* 함수가 한번만 사용된다면, 람다 함수를 통해 코드를 간결하게 만들 수 있다.\r\n\r\n```python\r\nnum_list = [-3, -2, -1, 0, 1, 2, 3]\r\n\r\nfor n in filter(lambda x: x > 0, num_list):\r\n    print(n, end = ' ')\r\n```\r\n\r\n```shell\r\n1 2 3 \r\n```\r\n\r\n<br>\r\n\r\n## 맵 함수\r\n\r\n맵 함수는 반복 가능한 자료형의 각 요소들에 대하여 지정한 함수를 적용한 뒤, 반복 가능한 자료형을 반환한다.\r\n맵 함수의 문법은 다음과 같다.\r\n\r\n```python\r\nmap([적용할 함수], [반복 가능 객체])\r\n```\r\n\r\n어려운 내용은 아니지만, 글로만 보면 이해에 어려움을 겪을 수 있다. 아래 예제를 보면 도움이 될 것이다.\r\n\r\n```python\r\ndef square(x):\r\n    return x ** 2\r\n\r\nnum_list = [-3, -2, -1, 0, 1, 2, 3]\r\n\r\nsquare_list = map(square, num_list)\r\nprint(list(square_list))\r\nprint(list(map(lambda x: x ** 2, num_list)))\r\n```\r\n\r\n```shell\r\n[9, 4, 1, 0, 1, 4, 9]\r\n[9, 4, 1, 0, 1, 4, 9]\r\n```\r\n\r\n위와 같이, 직접 함수를 만들어서 적용하여도 되고, 람다 함수를 통해 map을 사용해도 같은 결과값이 나오는 것을 확인할 수 있다.\r\n\r\n<br>\r\n\r\n## 리스트 축약 표현\r\n\r\n람다 함수, 필터, 맵을 통해 리스트를 축약해서 표현할 수 있다. 또한 리스트 뿐만 아니라 반복 가능 객체는 모두 가능하다. 리스트 축약 표현의 문법은 다음과 같다.\r\n\r\n```python\r\n[ {표현식} for {변수} in {반복자/연속열} if {조건 표현식}]\r\n```\r\n\r\n위에서 나오는 **{표현식}** 은 **맵** 의 기능을 수행하고, **{조건 표현식}** 은 **필터** 의 기능을 수행한다. 그리고 조건 표현식은 생략 가능하다. 아래 예제를 통해 자세히 살펴보자.\r\n\r\n```python\r\nnum_list = [-3, -2, -1, 0, 1, 2, 3]\r\nsquare_list = [x ** 2 for x in num_list]            # 리스트의 모든 값 제곱\r\npositive_square_list = [x ** 2 for x in num_list if x > 0]          # 리스트의 양수 값 제곱\r\n\r\nprint(list(square_list))\r\nprint(list(positive_square_list))\r\n```\r\n\r\n```shell\r\n[9, 4, 1, 0, 1, 4, 9]\r\n[1, 4, 9]\r\n```\r\n\r\n이를 응용하면, 두 리스트의 곱을 짧은 코드로 얻을 수 있다.\r\n\r\n```python\r\nproduct_list = [x * y for x in [1, 2, 3, 4] for y in [2, 4, 6]]\r\nprint(product_list)\r\n```\r\n\r\n```shell\r\n[2, 4, 6, 4, 8, 12, 6, 12, 18, 8, 16, 24]\r\n```\r\n\r\n조건 표현식 또한 다양하게 사용할 수 있다.\r\n\r\n```python\r\nlist1 = [n for n in range(1, 31) if n % 2 == 0 or n % 3 == 0]       # 1-30 중에서 2 또는 3의 배수\r\nlist2 = [n for n in range(1, 31) if n % 2 == 0 if n % 3 == 0]       # 1-30 중에서 2와 3의 배수\r\n\r\nprint(list1)\r\nprint(list2)\r\n```\r\n\r\n```python\r\n[2, 3, 4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 26, 27, 28, 30]\r\n[6, 12, 18, 24, 30]\r\n```\r\n\r\n<br>\r\n\r\n## 제너레이터\r\n\r\n제너레이터는 반복자와 거의 유사하다. 다만, 반복자와 다른 점은 모든 값을 메모리에 올려두고 사용하는 것이 아니라, 필요할 때마다 생성해서 반환하는 일을 한다.  따라서 메모리에 보관해놓지 않으니, 메모리를 효율적으로 사용할 수 있다는 장점이 있다. 이런 점 때문에, 한번 제너레이터를 실행하면, 다음에는 아무런 객체도 반환하지 않는다.\r\n제너레이터와 같이 쓰이는 ***yield*** 라는 함수가 있다. 이는 함수의 ***return*** 과 비슷하다. 그러나 yield는 제너레이터를 반환한다는 점에서 return과 차이가 있다\r\n아래 예시를 통해 확인해보자.\r\n\r\n```python\r\ndef create_generator():\r\n    for x in range(1, 4):\r\n        yield x\r\n\r\nmy_generator = create_generator()\r\nprint('첫번째 제너레이터 실행')\r\nfor n in my_generator:\r\n    print(n)\r\n\r\nprint('두번째 제너레이터 실행')\r\nfor n in my_generator:\r\n    print(n)\r\n```\r\n\r\n```shell\r\n첫번째 제너레이터 실행\r\n1\r\n2\r\n3\r\n두번째 제너레이터 실행\r\n```\r\n\r\n위와 같이, 제너레이터를 한번 실행하면, 다음번에는 아무것도 반환하지 않기 때문에 주의해야 한다.\r\n\r\n<br>\r\n\r\n## 끝맺음\r\n\r\n여기까지가 파이썬의 기초이다. 파이썬에 대해 가물가물한 사람들은 한번 보면 도움이 될 것이다.","excerpt":"예외처리 예외처리는 프로그램의 예상치 못한 종료나, 치명적인 오류를 예방할 수 있는 방법 중 하나이다. 따라서 꼼꼼하게 예외처리를 해 주는 것이 굉장이 중요하다고 할 수 있다. 이에 사용되는 것이 try-except-else(finally) 문이다.…","fields":{"slug":"/python-basic_2/"},"frontmatter":{"date":"Nov 25, 2020","title":"파이썬 기초 2","tags":["python"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n## 파이썬을 다시 공부하다 알게된 점\r\n\r\n필자는 파이썬으로 개발을 하면서 파이썬 기본서를 본 적이 없다. 다른 언어를 하면서 익힌 내용들을 바탕으로 구글링을 통해 개발을 하였다.\r\n그래서 이번에 파이썬 개발서를 한번 훑다가 몰랐던 기능들 혹은 정리하고 싶은 내용들을 정리하려고 한다. '파이썬 기초' 를 포스트 하면서 ***으뜸 파이썬(박동규, 강영민 지음)*** 책을 참고하였다. 자세한 내용은 책을 참고하면 좋을 것 같다.\r\n<br><br>\r\n\r\n## 복소수\r\n\r\n파이썬에서는 복소수를 표현할 수 있다. 여기서 주의할 점은 허수부에 *'i'* 대신 *'j'*를 사용한다는 것이다. 아래 예제로 확인해보자.\r\n\r\n```python\r\nc = 3 + 4i  # i 대신 j를 써야함\r\n\r\nSyntaxError: invalid syntax\r\n```\r\n\r\n```python\r\nc = 3 + 4j\r\nc.real  # c의 실수부 출력\r\n> 3.0\r\n\r\nc.imag  # c의 허수부 출력\r\n> 4.0\r\n```\r\n\r\n복소수 관련 추가적인 함수들이 있다. 아래 예제로 확인해보자.\r\n\r\n```python\r\nc = 3 + 4j\r\nc.conjugate() # c의 켤레 복소수\r\n> 3 - 4j\r\n\r\nabs(c)        # c의 복소평면에서의 원점까지의 거리\r\n> 5\r\n```\r\n<br>\r\n\r\n## 할당문\r\n\r\n변수에 값을 할당하는 방법은 모두 잘 알고있을 것이다. 파이썬에서는 _'동시 할당문'_ 이라는 재밌는 기능이 있다. 아래 예제로 확인해보자.\r\n\r\n```python\r\nnum = 10                  # 기본 할당문\r\n\r\nnum1 = num2 = num3 = 100  # 다중 할당문\r\nprint(num1, num2, num3)\r\n> 100, 100, 100\r\n\r\nnum4, num5 = 400, 500     # 동시 할당문\r\nprint(num4, num5)\r\n> 400, 500\r\n```\r\n<br>\r\n\r\n## 비트 연산자\r\n\r\n비트 연산자에 경우, 필자의 경험상 많이 사용하지 않는다. 직관적이지 않고 혼동의 우려가 있기 때문에 선호하지는 않지만, 굳이 비트 연산자를 사용하는 경우가 있다. 이는 비트 연산자가 가진 큰 장점 때문인데, ***연산이 빠르다는 것***이다. 아래 표를 통해 비트 연산자를 정리해두었다.\r\n\r\n| 연산자 | 의미 | 설명 |\r\n|:---:|:---|---|\r\n| & | 비트 단위 AND | 두 피연산자의 해당 비트가 모두 1이면 1, 아니면 0 |\r\n| \\| | 비트 단위 OR | 두 피연산자의 해당 비트가 하나라도 1이면 1, 아니면 0 |\r\n| ^ | 비트 단위 XOR | 두 피연산자의 해당 비트가 값이 같으면 1, 아니면 0 |\r\n| ~ | 비트 단위 NOT | 피연산자의 해당 비트가 0이면 1, 1이면 0 |\r\n| << | 비트 단위 왼쪽으로 이동 | 지정된 개수만큼 모든 비트를 왼쪽으로 이동 |\r\n| >> | 비트 단위 오른쪽으로 이동 | 지정된 개수만큼 모든 비트를 오른쪽으로 이동 |\r\n\r\n파이썬에서 이진수 값을 확인하는 방법은 간단하다. _'bin'_ 함수를 사용하면 쉽게 이진수 형식으로 출력이 가능하다. 아래 예제로 확인해보자.\r\n\r\n```python\r\nbin(9)    # 2진수 형식으로 출력\r\n> '0b1001'  # 0b는 binary라는 의미\r\n```\r\n<br>\r\n\r\n## 루프 제어변수 익명화\r\n\r\n불필요한 메모리 사용을 줄이기 위해, 혹은 한번만 사용할 것에 대해 이름을 정하는 것이 불필요하다고 생각할 수 있다. 이를 위해 **익명화** 라는 기능이 있다. 아래 예제를 보며 알아가보자.\r\n\r\n```python\r\nfor i in range(3):\r\n    print('Hello World')\r\n\r\n> Hello World\r\n> Hello World\r\n> Hello World\r\n\r\nfor _ in range(3):    # 루프 변수의 익명화\r\n    print('Hello World')\r\n\r\n> Hello World\r\n> Hello World\r\n> Hello World\r\n```\r\n\r\n**\\+** range\r\n  추가적으로 range에 대해 조금 설명을 하자면, range는 세가지 변수를 가질 수 있다.  \r\n<br>\r\n\r\n  ```python\r\n  range(start, stop, step)\r\n  ```\r\n<br>\r\n\r\n  **start**는 시작값을 지정해주는 변수로, 생략시 0으로 할당된다.\r\n  **stop**은 반복이 끝나는 시점을 알려주는 변수로, stop 보다 작은 경우에 반복한다.\r\n  **step**은 증가값을 지정해주는 변수로, 생략시 1로 할당된다.\r\n<br><br>\r\n\r\n  여기서 주의할 점은, stop이 ***'미만'*** 이므로 0부터 10까지의 정수 출력을 원한다면, _range(0, 10, 1)_이 아닌, **range(0, 11, 1)**을 해야한다.\r\n\r\n<br>\r\n\r\n## 반복문의 break, continue\r\n\r\n반복문에서 특정 조건일 때, 반복을 그만하거나 건너뛰고 싶을 수 있다. 그럴때 break 혹은 continue를 사용하면 프로그램 제어를 효율적으로 할 수 있다. 아래 예시를 통해 확인해보자.\r\n\r\n```python\r\nst = 'start'\r\n\r\n# 모음을 찾으면 반복문 종료\r\nfor ch in st:\r\n    if ch in ['a', 'e', 'i', 'o', 'u']:\r\n        break\r\n    print(ch, end = '')\r\n\r\n> st\r\n```\r\n\r\n```python\r\nst = 'start'\r\n\r\n# 자음만 출력\r\nfor ch in st:\r\n    if ch in ['a', 'e', 'i', 'o', 'u']:\r\n        continue            # 모음이면, 아래 print 함수 건너뜀\r\n    print(ch, end = '')\r\n\r\n> strt\r\n```\r\n<br>\r\n\r\n> break와 continue는 프로그램 제어에 효과적이지만, 너무 많이 사용하면 제어 흐름에 일관성이 없어져 프로그램 이해에 어려움을 겪을 수 있다.\r\n따라서 필요한 경우에만 사용하는 것을 권장한다.\r\n\r\n<br><br>\r\n\r\n## 함수의 전역변수 참조, 인자 전달\r\n\r\n전역변수를 자주 사용하는 것은 에러의 주 원인이 된다. 따라서 사용을 최대한 줄여야하지만, 불가피하게 사용해야할 경우가 있다. 이 때, 함수에서 전역변수의 참조 방법을 설명하려고 한다. 다음 예제로 확인해보자.\r\n\r\n```python\r\ndef print_sum():\r\n    global a, b\r\n    a, b = 10, 20\r\n    result = a + b\r\n    print('함수 내부의 sum:', result)       # a, b는 함수 외부에서 선언된 변수를 사용함\r\n\r\na, b = 1, 2\r\nprint_sum()       # 두 전역변수를 a = 10, b = 20으로 변환\r\nresult = a + b\r\nprint('함수 외부의 sum:', result)\r\n```\r\n\r\n<span style=\"color: skyblue;\">실행 결과</span>\r\n```shell\r\n함수 내부의 sum: 30\r\n함수 외부의 sum: 30\r\n```\r\n\r\n단, ***'global'*** 은 할당문에서 사용할 수 없다.\r\n```python\r\nglobal a = 10   # 문법오류 발생\r\n```\r\n\r\n<br>\r\n\r\n또한 함수를 호출할 때, 인자를 빠뜨리더라도 에러가 발생하지 않도록 할 수 있다. 바로 ***디폴트 인자*** 를 통해 매개변수에 기본값을 할당해 줄 수 있다. 아래 예제를 통해 확인해보자.\r\n\r\n```python\r\ndef print_star(n = 1):      # 매개변수는 기본값으로 1을 가짐\r\n    for _ in range(n):\r\n        print('*', end = '')\r\n    print('')\r\n\r\nprint_star()      # 인자를 전달하지 않아, n = 1 설정됨\r\nprint_star(5)     # 5를 인자로 전달하여, n = 1 은 수행되지 않음\r\n```\r\n\r\n<span style=\"color: skyblue;\">실행 결과</span>\r\n```shell\r\n*\r\n*****\r\n```\r\n\r\n단, 디폴트 매개변수를 할당할 때는, 전체 매개변수에 할당하거나, **매개변수 출현 순서상 뒤에 있는 변수부터 할당**해야한다.\r\n아래 예제를 통해 구체적으로 확인해보자.\r\n\r\n```python\r\ndef sum_first(a, b = 2):\r\n    return a + b\r\n\r\nprint('first sum:', sum_first(1))\r\n```\r\n<span style=\"color: skyblue;\">실행 결과</span>\r\n```shell\r\nfirst sum: 3\r\n```\r\n\r\n<br>\r\n\r\n위와 달리, 첫번째 매개변수에 디폴트 값을 지정해주면 오류가 발생한다.\r\n\r\n```python\r\ndef sum_second(a = 1, b):       # 디폴트 매개변수 오류\r\n    return a + b\r\n\r\nprint('second sum:', sum_second(2))\r\n```\r\n<span style=\"color: skyblue;\">실행 결과</span>\r\n```shell\r\nSyntaxError: non-default argument follows default argument\r\n```\r\n\r\n<br>\r\n\r\n## 객체의 식별값\r\n\r\n파이썬은 많은 내장함수를 가지고 있다. 그 중, ***id()*** 를 알아보자.  \r\n파이썬은 객체지향 프로그래밍 언어로, 객체마다 다른 객체와 구별되는 고유한 **식별값**을 갖는다. 이를 정수형으로 반환해주는 함수가 바로 ***id()***이다. 아래 예제로 확인해보자.\r\n\r\n```python\r\nstr_a = \"HELLO!\"\r\nid(str_a)\r\n\r\n> 21989600\r\n\r\nn = 100\r\nid(n)\r\n\r\n> 1919929824\r\n```\r\n\r\n<br>\r\n\r\n## zip() 함수\r\n\r\n파이썬에서는 반복가능 자료형으로 분류되는 자료형이 있다. 여기에는 리스트, 딕셔너리, 집합, 튜플과 같은 자료형들이 있다. 이러한 자료형을 여러개 넘겨주면, 이들을 합쳐 튜플 반복자를 반환하는 함수가 바로 zip() 함수이다. 글로만 봤을때는 이해가 잘 안될 것이다. 아래 예제로 자세히 살펴보자.\r\n\r\n```python\r\nstr_list = ['first', 'second', 'third']\r\nint_tuple = (100, 200, 300, 400, 500)\r\nfruit_list = ['apple', 'banana', 'orange', 'grape']\r\n\r\niterator = zip(str_list, int_tuple, fruit_list)\r\nlist(iterator)\r\n\r\n> [('first', 100, 'apple'), ('second', 200, 'banana'), ('third', 300, 'orange')]\r\n```\r\n\r\n예제를 살펴보면, 같은 인덱스의 데이터끼리 묶어서 반환하는 것을 알 수 있다.\r\n또한 세 반복가능 데이터의 길이가 3, 5, 4로 다 다르다. 이 경우, 가장 작은 길이인 3까지의 튜플 반복자를 생성함을 알 수 있다.  \r\n\r\n<br>\r\n\r\n여기서, 더 많은 원소를 가진 리스트로 순서 쌍을 만들고 싶다면, itertools 모듈을 import해 zip_longest를 사용해야한다. zip_longest를 사용하면, 부족한 원소는 None으로 처리한다. 아래 예제를 통해 확인해보자.\r\n\r\n```python\r\nimport itertools as it\r\n\r\nlist_1 = [1, 2, 3, 4]\r\nlist_2 = [11, 22, 33, 44, 55]\r\n\r\nfor i in it.zip_longest(list_1, list_2):\r\n    print(i)\r\n```\r\n\r\n```shell\r\n(1, 11)\r\n(2, 22)\r\n(3, 33)\r\n(4, 44)\r\n(None, 55)\r\n```\r\n\r\n<br>\r\n\r\n### - chain()\r\n\r\nitertools 모듈을 언급하였으니, 모듈이 가지고 있는 함수 중 몇가지만 더 소개하겠다.  \r\n**chain()** 함수는 2개의 리스트를 하나로 묶어 원소를 반환하는 함수이다.\r\n\r\n```python\r\nimport itertools as it\r\n\r\nlist_1 = [1, 2, 3, 4]\r\nlist_2 = [11, 22, 33, 44, 55]\r\n\r\nchain_list = list(it.chain(list_1, list_2))\r\nprint(chain_list)\r\n```\r\n\r\n```shell\r\n[1, 2, 3, 4, 11, 22, 33, 44, 55]\r\n```\r\n\r\n실행 결과를 확인하면 list_1 원소 이후에 list_2 원소가 붙게됨을 알 수 있다.\r\n\r\n<br>\r\n\r\n### - combinations()\r\n\r\n**combinations()** 함수는 리스트 원소 중 n개를 선택해서 중복되지 않는 모든 경우의 수를 반환한다.\r\n\r\n```python\r\nimport itertools as it\r\nlist_1 = [1, 2, 3]\r\n\r\ncombi_list = list(it.combinations(list_1, 3))\r\nprint(combi_list)\r\n```\r\n\r\n```shell\r\n[(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]\r\n```\r\n\r\n실행 결과를 확인하면 list_1의 원소들 중 3개를 중복없이 뽑는 경우의 수를 리스트로 출력한다. 이 때, 리스트 원소의 타입은 튜플이다.\r\n\r\n<br>\r\n\r\n### - permutations()\r\n\r\n**permutations()** 함수는 리스트 원소 중 n개를 선택하여, 원소 순서에 따른 모든 경우의 수를 반환한다.\r\n\r\n```python\r\nimport itertools as it\r\nlist_1 = [1, 2, 3, 4]\r\n\r\npermu_list = list(it.permutations(list_1, 2))\r\nprint(permu_list)\r\n```\r\n\r\n```shell\r\n[(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]\r\n```\r\n\r\n*combination()* 과 *permutations()* 의 다른 점은 순서를 무시하느냐, 고려하느냐의 차이이다.","excerpt":"파이썬을 다시 공부하다 알게된 점 필자는 파이썬으로 개발을 하면서 파이썬 기본서를 본 적이 없다. 다른 언어를 하면서 익힌 내용들을 바탕으로 구글링을 통해 개발을 하였다.\n그래서 이번에 파이썬 개발서를 한번 훑다가 몰랐던 기능들 혹은 정리하고 싶은 …","fields":{"slug":"/python-basic_1/"},"frontmatter":{"date":"Nov 23, 2020","title":"파이썬 기초 1","tags":["python"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n## 소개\r\n\r\n안녕하세요 저는 대학교에서 소프트웨어학과를 다니고 있는 학생입니다.\r\n제가 공부한 내용을 정리함과 동시에 다른 사람과 공유하면 좋을 것 같습니다.\r\n제가 아직 부족해서 게시글 중에 잘못된 정보가 포함되어 있을 수 있습니다.\r\n혹시 발견하시면 부담없이 댓글로 알려주시면 감사할 것 같습니다.\r\n\r\n## 블로그를 하게 된 계기\r\n\r\n사실 앞으로 살면서 내가 블로그를 하게 될 거라는 상상조차 하지 못할 정도로 블로그에 관심이 없었다.\r\n그러던 와중에, 학교 공부를 하면서 내가 배운 내용들을 제대로 알고 있는 것인가에 대한 의문이 생기기 시작했다.\r\n\r\n어려서부터 스스로 기본이 탄탄하지 않다고 생각할 때 불안함을 많이 느끼는 성향이 있었다.\r\n그래서 현재 하는 공부에 대해 기본이 튼튼한가? 라는 질문을 스스로에게 던지게 되었고, 답은 '아니다'라고 결론을 내리게 되었다.\r\n물론 지금 내가 하는 생각에 공감하지 못하는 사람도 있을 것이다.\r\n\r\n_이 분야는 기존의 것에 집중하기 보다는 새로운 것을 받아들이고\r\n응용하는 것에 초점을 두는 것이 좋다, 필요한 정보만 가져가는 것이 효율적으로 옳다_ 라고.\r\n나도 이 말에 공감한다. 나또한 이런 생각에 많이 고민했었다.\r\n그러나 모든 학문에는 뿌리가 되는 내용이 있고, 그것을 바탕으로 시작한다고 생각한다.\r\n그래서 스스로 정리하고 가면 좋을 것 같은 내용을 공부하고, 정리해야겠다는 생각을 하였다.\r\n\r\n이런 생각을 하던 와중에, 같이 프로젝트를 하던 형에게 블로그를 해보는 것은 어떠냐고 추천을 받았다.\r\n공부한 내용을 정리하는데 블로그만한 것이 없다고 하여 시작하게 되었다.\r\n\r\n\r\n\r\n## 블로그 테마\r\n\r\n블로그 설정을 하며 여러가지 테마를 찾아보고 고민했다. 그중에 minimal-mistake로 결정을 하게 되었다.\r\n블로그 초기 설정을 하면서도 내가 많이 부족한 탓에 많이 애먹었다. 그러다 _Junho Baik_ 님이 정리하신 글을 보게 되었다.\r\n거기서 _Junho Baik_ 님이 만드신 *[\"Borderless\"](https://github.com/junhobaik/junhobaik.github.io 'Borderless Github Homepage')* 라는 테마를 알게 되었고, 내가 생각하는 블로그 이미지에 적합하다고 생각되어 사용하게 되었다.\r\n\r\n\r\n   \r\n   \r\n## 끝맺음\r\n\r\n아직 많이 부족하지만, 잘못된 정보 없이 글을 작성하려고 노력하겠다. 내 블로그로 인해 누군가 도움을 받고, 나도 성장할 수 있었으면 좋겠다.\r\n","excerpt":"소개 안녕하세요 저는 대학교에서 소프트웨어학과를 다니고 있는 학생입니다.\n제가 공부한 내용을 정리함과 동시에 다른 사람과 공유하면 좋을 것 같습니다.\n제가 아직 부족해서 게시글 중에 잘못된 정보가 포함되어 있을 수 있습니다.\n혹시 발견하시면 부담없이…","fields":{"slug":"/intro/"},"frontmatter":{"date":"Nov 20, 2020","title":"블로그 소개","tags":["intro"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}