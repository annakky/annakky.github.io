{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\n## 예외처리\r\n\r\n예외처리는 프로그램의 예상치 못한 종료나, 치명적인 오류를 예방할 수 있는 방법 중 하나이다. 따라서 꼼꼼하게 예외처리를 해 주는 것이 굉장이 중요하다고 할 수 있다. 이에 사용되는 것이 **try-except-else(finally)** 문이다.\r\n\r\n|이름|설명|\r\n|:---:|---|\r\n|try:|예외 처리를 할 부분|\r\n|except:|예외가 발생했을 때 실행할 코드|\r\n|else:|예외가 발생하지 않았을 때 실행할 코드|\r\n|finally:|예외 발생 여부와 상관없이 실행할 코드|\r\n\r\n위 표에서 볼 수 있듯이, 예외 처리를 할 코드를 try 문에 넣은 뒤, 예외 발생 여부에 따른 코드를 알맞게 사용하면 된다. 아래 예시로 자세히 살펴보자.\r\n\r\n```python\r\nnum1, num2 = input(\"나눗셈을 할 숫자를 2개 넣어주세요: \").split()\r\ntry:\r\n    result = int(num1) / int(num2)\r\nexcept ValueError:\r\n    print('오류 : 입력 값이 실수가 아닙니다.')\r\nexcept:\r\n    print('오류 발생')\r\nelse:\r\n    print(\"결과:\", result)\r\nfinally:\r\n    print(\"프로그램 종료\")\r\n```\r\n\r\n<br>\r\n\r\n<span style=\"color: skyblue;\">실행 결과</span>\r\n\r\n```shell\r\n나눗셈을 할 숫자를 2개 넣어주세요: 10 2\r\n결과: 5.0\r\n프로그램 종료\r\n```\r\n\r\n```shell\r\n나눗셈을 할 숫자를 2개 넣어주세요: a b\r\n오류 : 입력 값이 실수가 아닙니다.\r\n프로그램 종료\r\n```\r\n\r\n```shell\r\n나눗셈을 할 숫자를 2개 넣어주세요: 10 0\r\n오류 발생\r\n프로그램 종료\r\n```\r\n\r\n위 예제처럼, except 뒤에 추가적으로 error type을 지정하여, 특정 에러일 경우를 핸들링할 수 있다.\r\n실행 결과를 보면, *'a, b'* 처럼 실수가 아닌 값을 입력하면, ValueError 이므로, **'except ValueError'** 가 실행된다.\r\n두번째 입력값에 0을 넣게 되면, *ZeroDivisionError*가 발생하여, **'except'** 가 실행된다.\r\nZeroDivisionError만 특별히 핸들링하고 싶다면, **'except ZeroDivisionError:'** 로 구성하면 된다.\r\n\r\n<br>\r\n\r\n## 클래스\r\n\r\n### - 초기화 메소드\r\n\r\n파이썬이 객체 지향 프로그래밍 언어인 것은 누구나 다 알 것이다. 그 OOL에 걸맞게 클래스를 잘 활용하기 위해, 클래스에 대해 자세히 아는 것이 중요하다. 객체는 정의될 때, 각 속성들을 초기화 및 할당해줘야한다. 마찬가지로 클래스도 마찬가지로 정의할 때 초기화를 해줘야하는데, 이 때 사용되는 것이 초기화 메소드, ***__init()__*** 이다. 아래 예제를 통해 자세히 확인해보자.\r\n\r\n```python\r\nclass Person:\r\n    def __init__(self, name, age):\r\n        self.name = name\r\n        self.age = age\r\n\r\n    def hi(self):\r\n        print(\"Hello!! My name is\", self.name, \"\\nI\\'m {} years old!\".format(self.age))\r\n\r\nminsoo = Person('MinSoo', 18)\r\nminsoo.hi()\r\n```\r\n\r\n```shell\r\nHello!! My name is MinSoo \r\nI'm 18 years old!\r\n```\r\n\r\n위 예제를 보면, 생성자의 첫 번째 매개변수는 **self** 로, 이는 생성한 인스턴스를 의미한다. 클래스 내에서는 인스턴스를 부를 방법이 없기 때문에 self를 사용한다.  \r\n\r\n<br>\r\n\r\n### - 문자열화 메소드\r\n\r\n이와 비슷한 메소드가 더 있다. [파이썬 기초 1](/python-basic_1/#--객체의-식별값)에서 확인할 수 있듯이, 모든 객체는 다른 객체와 구분되는 고유한 정보를 갖는데, 이를 **id** 라고 한다. 클래스 인스턴스도 객체이므로, id를 갖는다.\r\n\r\n```python\r\nprint(minsoo)\r\n```\r\n```shell\r\n<__main__.Person object at 0x0335F388>\r\n```\r\n\r\n'0x0335F388'가 바로 인스턴스의 아이디이다. 그러나 이를 통해 객체가 어떤 값을 가지고 있는지 알기 힘들다. 따라서 이를 도와주는 메소드가 바로 **__str__** 이다. 아래 예제로 자세히 살펴보자.\r\n\r\n```python\r\nclass Person:\r\n    def __init__(self, name, age):\r\n        self.name = name\r\n        self.age = age\r\n    \r\n    def __str__(self):\r\n        return ('Person(name = ' + self.name + ', age = ' + str(self.age) + ')')\r\n\r\n    def hi(self):\r\n        print(\"Hello!! My name is\", self.name, \"\\nI\\'m {} years old!\".format(self.age))\r\n\r\nminsoo = Person('MinSoo', 18)\r\nprint(minsoo)\r\n```\r\n\r\n```shell\r\nPerson(name = MinSoo, age = 18)\r\n```\r\n\r\n<br>\r\n\r\n### - 캡슐화\r\n\r\n클래스를 사용하면서, 클래스 속성에 함부로 접근하지 못하도록 하고 싶을 수 있다. 단순히 [인스턴스 명].[속성명] 으로 쉽게 접근하면, 예상치 못하게 속성값이 변할 수 있기 때문이다. 따라서 이를 방지하기 위해 캡슐화를 하여 클래스를 만든다.\r\nJava와 C++에서는 private이라는 키워드를 통해서 접근 제한이 가능하지만, 파이썬은 제공하지 않는다. 따라서 변수 이름에 표시를 해, private 변수라는 것을 확인할 수 있도록 한다. 아래 예제를 통해 확인해보자.\r\n\r\n```python\r\nclass Person:\r\n    def __init__(self, name, age):\r\n        self.__name = name\r\n        self.__age = age\r\n\r\n    def get_name(self):\r\n        return self.__name\r\n\r\n    def get_age(self):\r\n        return self.__age\r\n\r\n    def set_age(self, age):\r\n        if age > 0:\r\n            self.__age = age\r\n\r\nminsoo = Person('MinSoo', 18)\r\nprint(minsoo.get_name())\r\nminsoo.set_age(-5)\r\nprint(minsoo.get_age())\r\n```\r\n\r\n```shell\r\nMinSoo\r\n18\r\n```\r\n위 예제를 보면, 멤버변수에 ***__*** 혹은 ***_*** 로 시작하도록 하여 멤버 변수를 보호한다.\r\n이처럼, get_name(), get_age(), set_age()와 같은 멤버 함수만을 통하여 멤버변수로 접근할 수 있도록 한다.\r\n물론 'minsoo.\\__age'를 통해 접근할 수 있지만, 프로그래머들 사이에 약속을 한다면 private 변수와 같은 효과를 볼 수 있다.\r\n또한 요즘 개발 환경에서는 __ 혹은 _ 로 시작하는 멤버 변수에 접근하지 못하도록 하기도 한다.  \r\n\r\n<br>\r\n\r\n### - 특수 메소드\r\n\r\n클래스를 만들어 사용하다보면, 인스턴스를 위한 연산, 혹은 함수를 사용하고 싶을 수 있다. 아래 예제를 통해 먼저 살펴보자.\r\n\r\n```python\r\nclass Vector:\r\n    def __init__(self, x, y):\r\n        self.x = x\r\n        self.y = y\r\n\r\n    def __str__(self):\r\n        return '({}, {})'.format(self.x, self.y)\r\n\r\n    def add(self, other):       # 덧셈 함수\r\n        return Vector(self.x + other.x, self.y + other.y)\r\n\r\nv1 = Vector(1, 1)\r\nv2 = Vector(2, 2)\r\n\r\nprint(v1.add(v2))\r\n```\r\n\r\n```shell\r\n(3, 3)\r\n```\r\n\r\n<br>\r\n\r\n클래스의 다른 인스턴스와의 상호작용을 하고 싶을 때는, 위와 같이 other를 사용하면 된다. 그러나 두 벡터의 합을 표현하는데 *add()* 는 직관적이지 않고, 사용하기 불편하다. 이렇게 덧셈과 뺄셈 연산자를 사용하기 위해서는 특수 메소드를 구현해야한다.\r\n\r\n```python\r\nclass Vector:\r\n    def __init__(self, x, y):\r\n        self.x = x\r\n        self.y = y\r\n\r\n    def __str__(self):\r\n        return '({}, {})'.format(self.x, self.y)\r\n\r\n    def __add__(self, other):       # '+' 연산자\r\n        return Vector(self.x + other.x, self.y + other.y)\r\n\r\n    def __sub__(self, other):       # '-' 연산자\r\n        return Vector(self.x - other.x, self.y - other.y)\r\n\r\nv1 = Vector(1, 1)\r\nv2 = Vector(2, 2)\r\n\r\nv3 = v1 + v2\r\nv4 = v1 - v2\r\n\r\nprint(v3)\r\nprint(v4)\r\n```\r\n\r\n```shell\r\n(3, 3)\r\n(-1, -1)\r\n```\r\n\r\n'+', '-' 외에 다른 산술 연산자 뿐만 아니라, 비교 연산자, 내장 함수들까지 특수 메소드로 구현할 수 있다. 내장 함수들은 종류가 많아 따로 정리하지는 않았다. *len()* 함수를 *\\__len__()* 처럼 특수 메소드로 구현할 수 있으니, 잘 응용하면 될 것이다. 산술 연산자와 비교 연산자를 표를 통해 정리해놓았다. 아래 표를 통해 확인해보자.\r\n\r\n  * 산술 연산자\r\n\r\n|연산자|특수 메소드|하는 일|\r\n|:---:|:------:|----------|\r\n|x + y|\\__add__(self, other)|x와 y의 합|\r\n|x - y|\\__sub__(self, other)|x와 y의 차|\r\n|x * y|\\__mul__(self, other)|x와 y의 곱|\r\n|x ** y|\\__pow__(self, other)|x의 y 거듭제곱|\r\n|x / y|\\__truediv__(self, other)|x를 y로 나눈 값|\r\n|X // y|\\__floordiv__(self, other)|x를 y로 나눈 몫|\r\n|x % y|\\__mod__(self, other)|x를 y로 나눈 나머지|\r\n|+x|\\__pos__(self)|x의 양수|\r\n|-x|\\__neg__(self)|x의 음수|\r\n\r\n<br>\r\n\r\n  * 비교 연산자\r\n\r\n|연산자|특수 메소드|하는 일|\r\n|:---:|:------:|----------|\r\n|x < y|\\__lt__(self, other)|x가 y보다 작은가|\r\n|x <= y|\\__le__(self, other)|x가 y보다 작거나 같은가|\r\n|x >= y|\\__ge__(self, other)|x가 y보다 크거나 같은가|\r\n|x > y|\\__gt__(self, other)|x가 y보다 큰가|\r\n|x == y|\\__eq__(self, other)|x와 y가 같은가|\r\n|X != y|\\__ne__(self, other)|x와 y가 다른가|\r\n\r\n<br>\r\n\r\n### - 클래스 변수\r\n\r\n클래스에서, 모든 인스턴스가 공통적으로 갖는 특징이 있을 수 있다. 예를 들면, 원에 대한 클래스를 지정하는데, 원주율(PI)는 모든 원이 같은 값을 가진다. 따라서 생성자를 통해 계속 원마다 초기화하는 것보다, 모든 인스턴스가 공통적으로 갖는 변수로 지정하는게 효율적이다. 이를 클래스 변수라고 한다. 아래 예제를 통해 확인해보자.\r\n\r\n```python\r\nclass Circle:\r\n    PI = 3.141592       # 클래스 변수\r\n    def __init__(self, name, radius):\r\n        self.__name = name\r\n        self.__radius = radius\r\n\r\n    def area(self):\r\n        return Circle.PI * self.__radius ** 2\r\n\r\nc1 = Circle('C1', 4)\r\nprint(c1.area())\r\nc2 = Circle('C2', 3)\r\nprint(c2.area())\r\n```\r\n\r\n```shell\r\n50.265472\r\n28.274328\r\n```\r\n\r\n> 단, 클래스 내부에서 클래스 변수를 사용할 때는, *Circle.PI* 로 사용하여야 한다.\r\n\r\n<br>\r\n\r\n## 람다 함수\r\n\r\n이전 포스트 [파이썬 기초 1](/python-basic_1/#루프-제어변수-익명화) 에서 익명화에 대해 잠깐 언급한 적이 있다.\r\n이와 비슷하게, 람다 함수는 이름이 없는 특성 때문에 익명 함수라고도 불린다.\r\n람다 함수는 어떨때 보통 사용할까? 함수를 만들고 싶지 않지만 함수화 된 기능을 사용하고 싶거나, 1회용으로 사용할 함수를 만들고 싶을 때 많이 사용한다.    \r\n<br>\r\n그렇다면, 굳이 람다 함수를 사용하는 이유가 무엇일까? 이는 바로, 람다 함수를 사용하면 축약된 표현으로 코드가 간결해지고, 메모리 공간을 별도로 할당하지 않기 때문에 메모리를 절약할 수 있다. 람다 함수는 사용된 후, 힙 메모리에서 사라지기 때문이다. 그럼 람다 함수의 사용법에 대해 살펴보자.\r\n\r\n```python\r\nlambda [매개변수] : {표현식}\r\n```\r\n\r\n이해를 돕기 위해 예제를 준비했다.\r\n아래 예제를 통해 람다 함수에 대해 살펴보자.\r\n\r\n```python\r\ndef add(x, y):          # add 함수\r\n    return x + y\r\n\r\nprint('100 + 200 =', add(100, 200))\r\n\r\nprint('100 + 200 =', (lambda x, y: x + y)(100, 200))            # 람다 함수\r\n```\r\n\r\n```shell\r\n100 + 200 = 300\r\n100 + 200 = 300\r\n```\r\n\r\n위 예제를 보면, 동일한 결과값이 나오는 것을 확인할 수 있다. 위 예제는 일반적으로 람다 함수를 사용하는 방법은 아니지만, 람다 함수에 대해 이해할 수 있는 예제라고 생각된다. 람다 함수는 필터 혹은 맵과 함께 자주 사용된다. 그럼 필터 함수가 무엇인지 살펴보겠다.\r\n\r\n<br>\r\n\r\n## 필터 함수\r\n\r\n필터 함수는, 리스트와 같은 반복 가능한 요소들을 함수에 넣어 참인 것만 묶어서 반환한다. 필터 함수의 문법은 다음과 같다.\r\n\r\n```python\r\nfilter([적용할 함수], [반복 가능 객체])\r\n```\r\n\r\n이해를 돕기 위해, 아래 예제를 확인해보자.\r\n\r\n```python\r\ndef filter_positive(n):\r\n    if n > 0:\r\n        return True\r\n    else:\r\n        return False\r\n\r\nnum_list = [-3, -2, -1, 0, 1, 2, 3]\r\nfor n in filter(filter_positive, num_list):\r\n    print(n, end = ' ')\r\n```\r\n\r\n```shell\r\n1 2 3 \r\n```\r\n\r\n만약 *filter_positive()* 함수가 한번만 사용된다면, 람다 함수를 통해 코드를 간결하게 만들 수 있다.\r\n\r\n```python\r\nnum_list = [-3, -2, -1, 0, 1, 2, 3]\r\n\r\nfor n in filter(lambda x: x > 0, num_list):\r\n    print(n, end = ' ')\r\n```\r\n\r\n```shell\r\n1 2 3 \r\n```\r\n\r\n<br>\r\n\r\n## 맵 함수\r\n\r\n맵 함수는 반복 가능한 자료형의 각 요소들에 대하여 지정한 함수를 적용한 뒤, 반복 가능한 자료형을 반환한다.\r\n맵 함수의 문법은 다음과 같다.\r\n\r\n```python\r\nmap([적용할 함수], [반복 가능 객체])\r\n```\r\n\r\n어려운 내용은 아니지만, 글로만 보면 이해에 어려움을 겪을 수 있다. 아래 예제를 보면 도움이 될 것이다.\r\n\r\n```python\r\ndef square(x):\r\n    return x ** 2\r\n\r\nnum_list = [-3, -2, -1, 0, 1, 2, 3]\r\n\r\nsquare_list = map(square, num_list)\r\nprint(list(square_list))\r\nprint(list(map(lambda x: x ** 2, num_list)))\r\n```\r\n\r\n```shell\r\n[9, 4, 1, 0, 1, 4, 9]\r\n[9, 4, 1, 0, 1, 4, 9]\r\n```\r\n\r\n위와 같이, 직접 함수를 만들어서 적용하여도 되고, 람다 함수를 통해 map을 사용해도 같은 결과값이 나오는 것을 확인할 수 있다.\r\n\r\n<br>\r\n\r\n## 리스트 축약 표현\r\n\r\n람다 함수, 필터, 맵을 통해 리스트를 축약해서 표현할 수 있다. 또한 리스트 뿐만 아니라 반복 가능 객체는 모두 가능하다. 리스트 축약 표현의 문법은 다음과 같다.\r\n\r\n```python\r\n[ {표현식} for {변수} in {반복자/연속열} if {조건 표현식}]\r\n```\r\n\r\n위에서 나오는 **{표현식}** 은 **맵** 의 기능을 수행하고, **{조건 표현식}** 은 **필터** 의 기능을 수행한다. 그리고 조건 표현식은 생략 가능하다. 아래 예제를 통해 자세히 살펴보자.\r\n\r\n```python\r\nnum_list = [-3, -2, -1, 0, 1, 2, 3]\r\nsquare_list = [x ** 2 for x in num_list]            # 리스트의 모든 값 제곱\r\npositive_square_list = [x ** 2 for x in num_list if x > 0]          # 리스트의 양수 값 제곱\r\n\r\nprint(list(square_list))\r\nprint(list(positive_square_list))\r\n```\r\n\r\n```shell\r\n[9, 4, 1, 0, 1, 4, 9]\r\n[1, 4, 9]\r\n```\r\n\r\n이를 응용하면, 두 리스트의 곱을 짧은 코드로 얻을 수 있다.\r\n\r\n```python\r\nproduct_list = [x * y for x in [1, 2, 3, 4] for y in [2, 4, 6]]\r\nprint(product_list)\r\n```\r\n\r\n```shell\r\n[2, 4, 6, 4, 8, 12, 6, 12, 18, 8, 16, 24]\r\n```\r\n\r\n조건 표현식 또한 다양하게 사용할 수 있다.\r\n\r\n```python\r\nlist1 = [n for n in range(1, 31) if n % 2 == 0 or n % 3 == 0]       # 1-30 중에서 2 또는 3의 배수\r\nlist2 = [n for n in range(1, 31) if n % 2 == 0 if n % 3 == 0]       # 1-30 중에서 2와 3의 배수\r\n\r\nprint(list1)\r\nprint(list2)\r\n```\r\n\r\n```python\r\n[2, 3, 4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 26, 27, 28, 30]\r\n[6, 12, 18, 24, 30]\r\n```\r\n\r\n<br>\r\n\r\n## 제너레이터\r\n\r\n제너레이터는 반복자와 거의 유사하다. 다만, 반복자와 다른 점은 모든 값을 메모리에 올려두고 사용하는 것이 아니라, 필요할 때마다 생성해서 반환하는 일을 한다.  따라서 메모리에 보관해놓지 않으니, 메모리를 효율적으로 사용할 수 있다는 장점이 있다. 이런 점 때문에, 한번 제너레이터를 실행하면, 다음에는 아무런 객체도 반환하지 않는다.\r\n제너레이터와 같이 쓰이는 ***yield*** 라는 함수가 있다. 이는 함수의 ***return*** 과 비슷하다. 그러나 yield는 제너레이터를 반환한다는 점에서 return과 차이가 있다\r\n아래 예시를 통해 확인해보자.\r\n\r\n```python\r\ndef create_generator():\r\n    for x in range(1, 4):\r\n        yield x\r\n\r\nmy_generator = create_generator()\r\nprint('첫번째 제너레이터 실행')\r\nfor n in my_generator:\r\n    print(n)\r\n\r\nprint('두번째 제너레이터 실행')\r\nfor n in my_generator:\r\n    print(n)\r\n```\r\n\r\n```shell\r\n첫번째 제너레이터 실행\r\n1\r\n2\r\n3\r\n두번째 제너레이터 실행\r\n```\r\n\r\n위와 같이, 제너레이터를 한번 실행하면, 다음번에는 아무것도 반환하지 않기 때문에 주의해야 한다.","excerpt":"예외처리 예외처리는 프로그램의 예상치 못한 종료나, 치명적인 오류를 예방할 수 있는 방법 중 하나이다. 따라서 꼼꼼하게 예외처리를 해 주는 것이 굉장이 중요하다고 할 수 있다. 이에 사용되는 것이 try-except-else(finally) 문이다.…","fields":{"slug":"/python-basic_2/"},"frontmatter":{"date":"Nov 25, 2020","title":"파이썬 기초 2","tags":["python"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n## 파이썬을 다시 공부하다 알게된 점\r\n\r\n필자는 파이썬으로 개발을 하면서 파이썬 기본서를 본 적이 없다. 다른 언어를 하면서 익힌 내용들을 바탕으로 구글링을 통해 개발을 하였다.\r\n그래서 이번에 파이썬 개발서를 한번 훑다가 몰랐던 기능들 혹은 정리하고 싶은 내용들을 정리하려고 한다. '파이썬 기초' 를 포스트 하면서 ***으뜸 파이썬(박동규, 강영민 지음)*** 책을 참고하였다. 자세한 내용은 책을 참고하면 좋을 것 같다.\r\n<br><br>\r\n\r\n## 복소수\r\n\r\n파이썬에서는 복소수를 표현할 수 있다. 여기서 주의할 점은 허수부에 *'i'* 대신 *'j'*를 사용한다는 것이다. 아래 예제로 확인해보자.\r\n\r\n```python\r\nc = 3 + 4i  # i 대신 j를 써야함\r\n\r\nSyntaxError: invalid syntax\r\n```\r\n\r\n```python\r\nc = 3 + 4j\r\nc.real  # c의 실수부 출력\r\n> 3.0\r\n\r\nc.imag  # c의 허수부 출력\r\n> 4.0\r\n```\r\n\r\n복소수 관련 추가적인 함수들이 있다. 아래 예제로 확인해보자.\r\n\r\n```python\r\nc = 3 + 4j\r\nc.conjugate() # c의 켤레 복소수\r\n> 3 - 4j\r\n\r\nabs(c)        # c의 복소평면에서의 원점까지의 거리\r\n> 5\r\n```\r\n<br>\r\n\r\n## 할당문\r\n\r\n변수에 값을 할당하는 방법은 모두 잘 알고있을 것이다. 파이썬에서는 _'동시 할당문'_ 이라는 재밌는 기능이 있다. 아래 예제로 확인해보자.\r\n\r\n```python\r\nnum = 10                  # 기본 할당문\r\n\r\nnum1 = num2 = num3 = 100  # 다중 할당문\r\nprint(num1, num2, num3)\r\n> 100, 100, 100\r\n\r\nnum4, num5 = 400, 500     # 동시 할당문\r\nprint(num4, num5)\r\n> 400, 500\r\n```\r\n<br>\r\n\r\n## 비트 연산자\r\n\r\n비트 연산자에 경우, 필자의 경험상 많이 사용하지 않는다. 직관적이지 않고 혼동의 우려가 있기 때문에 선호하지는 않지만, 굳이 비트 연산자를 사용하는 경우가 있다. 이는 비트 연산자가 가진 큰 장점 때문인데, ***연산이 빠르다는 것***이다. 아래 표를 통해 비트 연산자를 정리해두었다.\r\n\r\n| 연산자 | 의미 | 설명 |\r\n|:---:|:---|---|\r\n| & | 비트 단위 AND | 두 피연산자의 해당 비트가 모두 1이면 1, 아니면 0 |\r\n| \\| | 비트 단위 OR | 두 피연산자의 해당 비트가 하나라도 1이면 1, 아니면 0 |\r\n| ^ | 비트 단위 XOR | 두 피연산자의 해당 비트가 값이 같으면 1, 아니면 0 |\r\n| ~ | 비트 단위 NOT | 피연산자의 해당 비트가 0이면 1, 1이면 0 |\r\n| << | 비트 단위 왼쪽으로 이동 | 지정된 개수만큼 모든 비트를 왼쪽으로 이동 |\r\n| >> | 비트 단위 오른쪽으로 이동 | 지정된 개수만큼 모든 비트를 오른쪽으로 이동 |\r\n\r\n파이썬에서 이진수 값을 확인하는 방법은 간단하다. _'bin'_ 함수를 사용하면 쉽게 이진수 형식으로 출력이 가능하다. 아래 예제로 확인해보자.\r\n\r\n```python\r\nbin(9)    # 2진수 형식으로 출력\r\n> '0b1001'  # 0b는 binary라는 의미\r\n```\r\n<br>\r\n\r\n## 루프 제어변수 익명화\r\n\r\n불필요한 메모리 사용을 줄이기 위해, 혹은 한번만 사용할 것에 대해 이름을 정하는 것이 불필요하다고 생각할 수 있다. 이를 위해 **익명화** 라는 기능이 있다. 아래 예제를 보며 알아가보자.\r\n\r\n```python\r\nfor i in range(3):\r\n    print('Hello World')\r\n\r\n> Hello World\r\n> Hello World\r\n> Hello World\r\n\r\nfor _ in range(3):    # 루프 변수의 익명화\r\n    print('Hello World')\r\n\r\n> Hello World\r\n> Hello World\r\n> Hello World\r\n```\r\n\r\n**\\+** range\r\n  추가적으로 range에 대해 조금 설명을 하자면, range는 세가지 변수를 가질 수 있다.  \r\n<br>\r\n\r\n  ```python\r\n  range(start, stop, step)\r\n  ```\r\n<br>\r\n\r\n  **start**는 시작값을 지정해주는 변수로, 생략시 0으로 할당된다.\r\n  **stop**은 반복이 끝나는 시점을 알려주는 변수로, stop 보다 작은 경우에 반복한다.\r\n  **step**은 증가값을 지정해주는 변수로, 생략시 1로 할당된다.\r\n<br><br>\r\n\r\n  여기서 주의할 점은, stop이 ***'미만'*** 이므로 0부터 10까지의 정수 출력을 원한다면, _range(0, 10, 1)_이 아닌, **range(0, 11, 1)**을 해야한다.\r\n\r\n<br>\r\n\r\n## 반복문의 break, continue\r\n\r\n반복문에서 특정 조건일 때, 반복을 그만하거나 건너뛰고 싶을 수 있다. 그럴때 break 혹은 continue를 사용하면 프로그램 제어를 효율적으로 할 수 있다. 아래 예시를 통해 확인해보자.\r\n\r\n```python\r\nst = 'start'\r\n\r\n# 모음을 찾으면 반복문 종료\r\nfor ch in st:\r\n    if ch in ['a', 'e', 'i', 'o', 'u']:\r\n        break\r\n    print(ch, end = '')\r\n\r\n> st\r\n```\r\n\r\n```python\r\nst = 'start'\r\n\r\n# 자음만 출력\r\nfor ch in st:\r\n    if ch in ['a', 'e', 'i', 'o', 'u']:\r\n        continue            # 모음이면, 아래 print 함수 건너뜀\r\n    print(ch, end = '')\r\n\r\n> strt\r\n```\r\n<br>\r\n\r\n> break와 continue는 프로그램 제어에 효과적이지만, 너무 많이 사용하면 제어 흐름에 일관성이 없어져 프로그램 이해에 어려움을 겪을 수 있다.\r\n따라서 필요한 경우에만 사용하는 것을 권장한다.\r\n\r\n<br><br>\r\n\r\n## 함수의 전역변수 참조, 인자 전달\r\n\r\n전역변수를 자주 사용하는 것은 에러의 주 원인이 된다. 따라서 사용을 최대한 줄여야하지만, 불가피하게 사용해야할 경우가 있다. 이 때, 함수에서 전역변수의 참조 방법을 설명하려고 한다. 다음 예제로 확인해보자.\r\n\r\n```python\r\ndef print_sum():\r\n    global a, b\r\n    a, b = 10, 20\r\n    result = a + b\r\n    print('함수 내부의 sum:', result)       # a, b는 함수 외부에서 선언된 변수를 사용함\r\n\r\na, b = 1, 2\r\nprint_sum()       # 두 전역변수를 a = 10, b = 20으로 변환\r\nresult = a + b\r\nprint('함수 외부의 sum:', result)\r\n```\r\n\r\n<span style=\"color: skyblue;\">실행 결과</span>\r\n```shell\r\n함수 내부의 sum: 30\r\n함수 외부의 sum: 30\r\n```\r\n\r\n단, ***'global'*** 은 할당문에서 사용할 수 없다.\r\n```python\r\nglobal a = 10   # 문법오류 발생\r\n```\r\n\r\n<br>\r\n\r\n또한 함수를 호출할 때, 인자를 빠뜨리더라도 에러가 발생하지 않도록 할 수 있다. 바로 ***디폴트 인자*** 를 통해 매개변수에 기본값을 할당해 줄 수 있다. 아래 예제를 통해 확인해보자.\r\n\r\n```python\r\ndef print_star(n = 1):      # 매개변수는 기본값으로 1을 가짐\r\n    for _ in range(n):\r\n        print('*', end = '')\r\n    print('')\r\n\r\nprint_star()      # 인자를 전달하지 않아, n = 1 설정됨\r\nprint_star(5)     # 5를 인자로 전달하여, n = 1 은 수행되지 않음\r\n```\r\n\r\n<span style=\"color: skyblue;\">실행 결과</span>\r\n```shell\r\n*\r\n*****\r\n```\r\n\r\n단, 디폴트 매개변수를 할당할 때는, 전체 매개변수에 할당하거나, **매개변수 출현 순서상 뒤에 있는 변수부터 할당**해야한다.\r\n아래 예제를 통해 구체적으로 확인해보자.\r\n\r\n```python\r\ndef sum_first(a, b = 2):\r\n    return a + b\r\n\r\nprint('first sum:', sum_first(1))\r\n```\r\n<span style=\"color: skyblue;\">실행 결과</span>\r\n```shell\r\nfirst sum: 3\r\n```\r\n\r\n<br>\r\n\r\n위와 달리, 첫번째 매개변수에 디폴트 값을 지정해주면 오류가 발생한다.\r\n\r\n```python\r\ndef sum_second(a = 1, b):       # 디폴트 매개변수 오류\r\n    return a + b\r\n\r\nprint('second sum:', sum_second(2))\r\n```\r\n<span style=\"color: skyblue;\">실행 결과</span>\r\n```shell\r\nSyntaxError: non-default argument follows default argument\r\n```\r\n\r\n<br>\r\n\r\n## 객체의 식별값\r\n\r\n파이썬은 많은 내장함수를 가지고 있다. 그 중, ***id()*** 를 알아보자.  \r\n파이썬은 객체지향 프로그래밍 언어로, 객체마다 다른 객체와 구별되는 고유한 **식별값**을 갖는다. 이를 정수형으로 반환해주는 함수가 바로 ***id()***이다. 아래 예제로 확인해보자.\r\n\r\n```python\r\nstr_a = \"HELLO!\"\r\nid(str_a)\r\n\r\n> 21989600\r\n\r\nn = 100\r\nid(n)\r\n\r\n> 1919929824\r\n```\r\n\r\n<br>\r\n\r\n## zip() 함수\r\n\r\n파이썬에서는 반복가능 자료형으로 분류되는 자료형이 있다. 여기에는 리스트, 딕셔너리, 집합, 튜플과 같은 자료형들이 있다. 이러한 자료형을 여러개 넘겨주면, 이들을 합쳐 튜플 반복자를 반환하는 함수가 바로 zip() 함수이다. 글로만 봤을때는 이해가 잘 안될 것이다. 아래 예제로 자세히 살펴보자.\r\n\r\n```python\r\nstr_list = ['first', 'second', 'third']\r\nint_tuple = (100, 200, 300, 400, 500)\r\nfruit_list = ['apple', 'banana', 'orange', 'grape']\r\n\r\niterator = zip(str_list, int_tuple, fruit_list)\r\nlist(iterator)\r\n\r\n> [('first', 100, 'apple'), ('second', 200, 'banana'), ('third', 300, 'orange')]\r\n```\r\n\r\n예제를 살펴보면, 같은 인덱스의 데이터끼리 묶어서 반환하는 것을 알 수 있다.\r\n또한 세 반복가능 데이터의 길이가 3, 5, 4로 다 다르다. 이 경우, 가장 작은 길이인 3까지의 튜플 반복자를 생성함을 알 수 있다.","excerpt":"파이썬을 다시 공부하다 알게된 점 필자는 파이썬으로 개발을 하면서 파이썬 기본서를 본 적이 없다. 다른 언어를 하면서 익힌 내용들을 바탕으로 구글링을 통해 개발을 하였다.\n그래서 이번에 파이썬 개발서를 한번 훑다가 몰랐던 기능들 혹은 정리하고 싶은 …","fields":{"slug":"/python-basic_1/"},"frontmatter":{"date":"Nov 23, 2020","title":"파이썬 기초 1","tags":["python"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n## 소개\r\n\r\n안녕하세요 저는 대학교에서 소프트웨어학과를 다니고 있는 학생입니다.\r\n제가 공부한 내용을 정리함과 동시에 다른 사람과 공유하면 좋을 것 같습니다.\r\n제가 아직 부족해서 게시글 중에 잘못된 정보가 포함되어 있을 수 있습니다.\r\n혹시 발견하시면 부담없이 댓글로 알려주시면 감사할 것 같습니다.\r\n\r\n## 블로그를 하게 된 계기\r\n\r\n사실 앞으로 살면서 내가 블로그를 하게 될 거라는 상상조차 하지 못할 정도로 블로그에 관심이 없었다.\r\n그러던 와중에, 학교 공부를 하면서 내가 배운 내용들을 제대로 알고 있는 것인가에 대한 의문이 생기기 시작했다.\r\n\r\n어려서부터 스스로 기본이 탄탄하지 않다고 생각할 때 불안함을 많이 느끼는 성향이 있었다.\r\n그래서 현재 하는 공부에 대해 기본이 튼튼한가? 라는 질문을 스스로에게 던지게 되었고, 답은 '아니다'라고 결론을 내리게 되었다.\r\n물론 지금 내가 하는 생각에 공감하지 못하는 사람도 있을 것이다.\r\n\r\n_이 분야는 기존의 것에 집중하기 보다는 새로운 것을 받아들이고\r\n응용하는 것에 초점을 두는 것이 좋다, 필요한 정보만 가져가는 것이 효율적으로 옳다_ 라고.\r\n나도 이 말에 공감한다. 나또한 이런 생각에 많이 고민했었다.\r\n그러나 모든 학문에는 뿌리가 되는 내용이 있고, 그것을 바탕으로 시작한다고 생각한다.\r\n그래서 스스로 정리하고 가면 좋을 것 같은 내용을 공부하고, 정리해야겠다는 생각을 하였다.\r\n\r\n이런 생각을 하던 와중에, 같이 프로젝트를 하던 형에게 블로그를 해보는 것은 어떠냐고 추천을 받았다.\r\n공부한 내용을 정리하는데 블로그만한 것이 없다고 하여 시작하게 되었다.\r\n\r\n\r\n\r\n## 블로그 테마\r\n\r\n블로그 설정을 하며 여러가지 테마를 찾아보고 고민했다. 그중에 minimal-mistake로 결정을 하게 되었다.\r\n블로그 초기 설정을 하면서도 내가 많이 부족한 탓에 많이 애먹었다. 그러다 _Junho Baik_ 님이 정리하신 글을 보게 되었다.\r\n거기서 _Junho Baik_ 님이 만드신 *[\"Borderless\"](https://github.com/junhobaik/junhobaik.github.io 'Borderless Github Homepage')* 라는 테마를 알게 되었고, 내가 생각하는 블로그 이미지에 적합하다고 생각되어 사용하게 되었다.\r\n\r\n\r\n   \r\n   \r\n## 끝맺음\r\n\r\n아직 많이 부족하지만, 잘못된 정보 없이 글을 작성하려고 노력하겠다. 내 블로그로 인해 누군가 도움을 받고, 나도 성장할 수 있었으면 좋겠다.\r\n","excerpt":"소개 안녕하세요 저는 대학교에서 소프트웨어학과를 다니고 있는 학생입니다.\n제가 공부한 내용을 정리함과 동시에 다른 사람과 공유하면 좋을 것 같습니다.\n제가 아직 부족해서 게시글 중에 잘못된 정보가 포함되어 있을 수 있습니다.\n혹시 발견하시면 부담없이…","fields":{"slug":"/intro/"},"frontmatter":{"date":"Nov 20, 2020","title":"블로그 소개","tags":["intro"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}