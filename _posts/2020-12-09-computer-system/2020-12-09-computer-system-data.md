---
title: 정보의 표현과 처리
date: 2020-12-09 12:01:00
tags:
  - Computer System
---

## 정보의 저장

### - 16진수

1바이트는 8비트로 이루어져 이다. 1바이트는 이진수로 표현하면 00000000<sub>2</sub> 에서 11111111<sub>2</sub> 까지의 범위의 값을 갖는다.
십진수로 표현하면 0<sub>10</sub> 에서 255<sub>10</sub> 의 범위를 갖는데, 이진수로 표현하기에는 너무 장황하고, 십진수로 표현하기에는 매번 변환을 해야한다.
그래서 2진수로 변환이 쉽고, 표현하는데 어려움이 없는 16진수로 표현하여, 하나의 바이트 값은 00<sub>16</sub> 에서 FF<sub>16</sub> 까지의 범위를 갖는다.  

C언어에서는 16진수를 표현하기 위해, 앞에 '0x' 혹은 '0X'를 사용한다. 또한 문자는 소문자, 대문자 구별없이 사용 가능하다. 예를 들어, 0xF4B12D 로 나타낼 수 있다. 앞으로 16진수를 표기하는데 있어 C언어의 표기법을 사용하겠다.  

|진수|||||||
|:---|---:|------:|------:|------:|------:|------:|
|Binary|0001|0111|0011|1010|0100|1100|
|Hexadecimal|    1|    7|    3|    A|    4|    C|

위 예제처럼, 이진수가 주어지면, 4비트씩 나누어 16진수로 변환하면 된다.

<br>

### - 주소지정과 바이트 순서

대부분의 컴퓨터에서 멀티 바이트 객체는 연속된 바이트에 저장되며, 객체의 주소는 사용된 바이트의 최소 주소로 정한다.
예를 들어, int 타입의 변수 x가 주소 0x100라 하자. x는 4바이트의 공간을 가지므로, x는 메모리 주소 0x100, 0x101, 0x102, 0x103에 저장될 것이다.  

여기서 x를 나타내는 비트를 [*x*<sub>*w - 1*</sub>, *x*<sub>*w - 2*</sub>, ... , *x*<sub>*1*</sub>, *x*<sub>*0*</sub>] 으로 *w*-비트 정수를 갖는다고 하자. 여기서 *x*<sub>*w - 1*</sub>은 가장 중요한 비트 (most significant bit)이고, *x*<sub>0</sub>은 가장 덜 중요한 비트이다. 예를 들면, 0x4F12AF 에서, 4는 가장 중요한 비트이고, F는 가장 덜 중요한 비트이다.  

컴퓨터 타입에 따라 객체를 메모리에 저장하는 순서가 달라지는데, 어떤 컴퓨터는 가장 중요한 바이트부터 저장하고, 어떤 컴퓨터는 가장 덜 중요한 바이트부터 저장한다. 전자를 ***빅 엔디안***이라 하고, 후자를 ***리틀 엔디안***이라 부른다.  

int형 변수 x가 주소 0x100에 있으며, 16진수 값 0x01234567을 갖는다고 하자.<br>

**Big endian**

||||||
|:---:|:---:|:---:|:---:|:---:|
|주소|<center>0x100</center>|<center>0x101</center>|<center>0x102</center>|<center>0x103</center>|
|값|<center style="border-left: 1px solid lightgray; border-right: 1px solid lightgray">01</center>|<center style="border-left: 1px solid lightgray; border-right: 1px solid lightgray">23</center>|<center style="border-left: 1px solid lightgray; border-right: 1px solid lightgray">45</center>|<center style="border-left: 1px solid lightgray; border-right: 1px solid lightgray">67</center>|

<br>

**Little endian**

||||||
|:---:|:---:|:---:|:---:|:---:|
|주소|<center>0x100</center>|<center>0x101</center>|<center>0x102</center>|<center>0x103</center>|
|값|<center style="border-left: 1px solid lightgray; border-right: 1px solid lightgray">67</center>|<center style="border-left: 1px solid lightgray; border-right: 1px solid lightgray">45</center>|<center style="border-left: 1px solid lightgray; border-right: 1px solid lightgray">23</center>|<center style="border-left: 1px solid lightgray; border-right: 1px solid lightgray">01</center>|

대부분의 프로그래머는 자신의 컴퓨터에서 사용되는 바이트 순서를 알 수 없기 때문에, 바이트 순서가 큰 문제가 되지 않는다. 그러나 바이트 순서가 이슈가 되기도 하는데, 이는 다른 컴퓨터로 이진 데이터를 전송할 때이다. 그러나 네트워크 표준을 통해 이러한 문제들을 해결하고 있다.

<br>

### - 쉬프트 연산

C언어에서는 비트 패턴을 좌우로 이동시키는 *쉬프트*연산을 제공한다. 먼저, 좌측 쉬프트에 대해 알아보자.  

좌측 쉬프트는 **x << k**로 표현하며, 비트 표시 [*x*<sub>*w - 1*</sub>, *x*<sub>*w - 2*</sub>, ... , *x*<sub>*1*</sub>, *x*<sub>*0*</sub>]를 [*x*<sub>*w - k - 1*</sub>, *x*<sub>*w - k - 2*</sub>, ... , *x*<sub>*1*</sub>, *x*<sub>*0*</sub>, 0, ... , 0]으로 만든다. 즉 좌측은 k비트만큼 밀려 삭제되며, 우측에는 k개의 0으로 채워진다.  

우측 쉬프트는 좌측과 다르게 두 종류의 쉬프트를 제공한다.  

> 논리 우측 쉬프트 : 좌측에 k개의 0으로 채워 [0, ... , 0, *x*<sub>*w - 1*</sub>, *x*<sub>*w - 2*</sub>, ..., *x*<sub>*k*</sub>]를 만든다.  <br><br>
> 산술 우측 쉬프트 : 좌측에 k개를 가장 중요한 비트와 동일하게 채워 [*x*<sub>*w - 1*</sub>, ... , *x*<sub>*w - 1*</sub>, *x*<sub>*w - 1*</sub>, *x*<sub>*w - 2*</sub>, ... , *x*<sub>*k*</sub>]로 만든다.

C언어에서는 어떤 타입의 우측 쉬프트가 사용되어야 하는지 명확하게 정의하고 있지 않지만, 일반적으로 부호형 데이터에서는 산술 쉬프트를, 비부호형 데이터에서는 논리 쉬프트를 사용한다.  

|쉬프트 타입|Value 1|Value 2|
|:---|:---:|:---:|
|x|[00110011]|[11001100]|
|x << 4|[0011***0000***]|[1100***0000***]|
|x >> 4 (logical)|[***0000***0011]|[***0000***1100]|
|x >> 4 (arithmetic)|[***0000***0011]|[***1111***1100]|

<br>

## 정수의 표시

컴퓨터는 0, 1만을 사용하여 모든 수를 표현해야 한다. 그렇다면 어떻게 정수를 2진수를 사용하여 표현할 수 있을까. 음수를 0, 1만으로 어떻게 표현할 수 있을까. 에 대한 의문이 생기기 마련이다. 컴퓨터가 정수를 표현하는 방법을 소개하겠다.

<br>

### - 비부호형

*w*비트의 정수형 데이터 타입이 있다고 하자. 이 정수는 [*x*<sub>*w - 1*</sub>, *x*<sub>*w - 2*</sub>, ..., *x*<sub>*0*</sub>]으로 표현된다. 비부호형은 unsigned로, 무조건 양수 혹은 0의 값만을 갖는다. 따라서 이 정수는 0 ~ 2<sup>*w*</sup> - 1 까지의 값을 갖는다.

    7  -> [0111]  
    14 -> [1110]

<br>

### - 2의 보수

부호형 데이터를 알아보기 전에 먼저 알아야 할 것이 있다. 바로 2의 보수이다. 부호형 숫자를 컴퓨터에서 표시하는 가장 일반적인 방법이 **2의 보수**로 많이 알려져 있다. 2의 보수는 가장 높은 자리에서 자리 올림 발생 시 무시하므로 1의 보수보다 계산이 간단하다. 이러한 특성때문에 2의 보수를 사용한다.

> 2의 보수란 어떤 수를 커다란 2의 제곱수에서 빼서 얻은 이진수이다. <sub>[[나무위키]](https://ko.wikipedia.org/wiki/2%EC%9D%98_%EB%B3%B4%EC%88%98)</sub>

2의 보수를 쉽게 구하는 방법은, 모든 자리 수를 반전(0은 1로, 1은 0으로)한 뒤, 1을 더하면 된다. 아래 예를 통해 확인해보자.

```
7  -> [0111]
-7 -> [1001]

5  -> [0101]
-3 -> [1101]
5 - 3 = [10010] -> [0010] = 2
```

<br>

### - 부호형

*w*비트의 정수형 데이터 타입이 있다고 하자. 이 정수는 [*x*<sub>*w - 1*</sub>, *x*<sub>*w - 2*</sub>, ..., *x*<sub>*0*</sub>]으로 표현된다. 부호형 정수는 signed로 음의 값을 가질 수 있다. 따라서 이 정수는 -2<sup>*w - 1*</sup> ~ 2<sup>*w - 1*</sup> - 1 까지의 값을 갖는다.

    7  -> [0111]  
    -2 -> [1110]
    7 + 7 -> [1110] = -2


위 예제처럼, 부호형에서는 두 수를 더했을 때 값이 완전히 달라질 수 있음에 유의하여야한다.

<br>

### - 비부호형과 부호형간의 변환

C는 비부호형과 부호형 간의 변환을 허용한다. 대부분의 시스템은 기본 비트 표시는 바뀌지 않는다는 규칙을 따른다. 따라서 변환시 값이 달라질 수 있음에 유의하여야한다. 아래 예시를 통해 확인해보자.

|비트표현|비부호형|부호형|
|:---:|:---:|:---:|
|[0101]|5|5|
|[1101]|13|-3|

<br>

### - 비트 확장

값은 동일하게 유지한 채, 더 큰 길이의 자료형으로 변환하는 것은 언제나 가능해야한다. 비트 확장은 산술 우측 쉬프트와 비슷하다. 아래 예제는 빅 엔디안 머신에서 32비트 프로그램으로 실행한 결과이다.

    short sx = -12345          : cf c7
    int x = sx                 : ff ff cf c7

    unsigned short usx = 53191 : cf c7
    unsigned int ux = usx      : 00 00 cf c7

위 예제처럼, 비부호형 정수의 경우 확장된 크기만큼 0을 왼쪽에 채운다. 부호형 정수의 경우는 확장된 크기만큼 가장 중요한 비트와 같은 값을 왼쪽에 채운다.

<br>

### - 숫자의 절삭

이번에는 작은 길이의 자료형으로 변환하여, 비트의 개수를 줄이는 경우를 살펴보자.

```c
int x = 53191;
short sx = (short) x;             // -12345

unsigned int a = 153191;
unsigned short sa = (short) a;    // 22119
```

정수 x는 비트 [*x*<sub>*w - 1*</sub>, *x*<sub>*w - 2*</sub>, ..., *x*<sub>*0*</sub>]을 갖는다고 하자. 이 때 k개의 비트를 갖도록 절삭한 결과를 x'이라하면, x'은 [*x*<sub>*k - 1*</sub>, *x*<sub>*k - 2*</sub>, ..., *x*<sub>*0*</sub>]을 갖게 된다. k의 자리수를 갖도록 왼쪽의 값을 모두 제거한다고 생각하면 쉽다.  

비부호형에서, x' = x mod 2<sup>k</sup>, 즉 x'은 x를 2의 k제곱으로 나눈 값과 같다. 부호형에서는 절삭 후 가장 중요한 비트를 부호비트로 바꾼다.  

위 예제와 같이, 숫자의 절삭에서 오버플로우가 일어나 값이 바뀔 수 있다는 것에 유의하여야한다.  

곱셈과 나눗셈, 특히 나눗셈은 덧셈과 비트 연산보다 훨씬 많은 시간을 필요로 한다. 따라서 ***'x * 15'*** 을 하는 것보다 ***'(x << 4) - x'*** 를 하는 것이 프로그램의 성능을 높일 수 있다. 다만 주의할 점은, 정수 연산시 오버플로우를 항상 고려하여 코드를 작성해야한다.

<br>

## 부동소수점

> 부동소수점이란, 실수를 컴퓨터상에서 근사하여 표현할 때 소수점의 위치를 고정하지 않고 그 위치를 나타내는 수를 따로 적는 것이다. <sub>[<위키백과>](https://ko.wikipedia.org/wiki/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90)</sub>

<br>

정의를 보면 와닫지 않을 수 있다. 쉽게 설명하면 컴퓨터 상에서 실수를 표현하기 어려우니, 실수를 하나의 틀에 넣고 그 틀을 이진수로 표현하면 컴퓨터도 실수를 표현할 수 있다고 생각해서 사용한 것이 부동소수점이다. 그래도 이해하기 어려울 수 있다. 이해를 돕기 위해, 널리 쓰이는 표준인 IEEE 부동소수점을 가지고 설명하겠다.  

IEEE 부동소수점 표준은 V = (-1)<sup>*s*</sup> X *M* X 2<sup>*E*</sup> 형태로 나타낸다.

 + 부호 ***s*** 는 실수가 음수인지(s = 1) 양수인지(s = 0) 결정한다.
 + 유효숫자 ***M*** 은 비율 이진수로 1과 2 - *ε* 사이 또는 0과 1 - *ε* 사이의 값을 갖는다.
 + 지수 ***E*** 는 2의 제곱으로 자리값을 제공한다.  

 부동소수점 수의 비트 표시는 이 값을 인코딩하기 위해 세 개의 필드로 나눠진다.  

+ 한 개의 부호 비트 ***s*** 는 부호 *s*를 직접 인코딩한다.
+ k비트 지수 필드 ***exp*** = *e*<sub>*k - 1*</sub>...*e*<sub>*1*</sub>*e*<sub>*0*</sub>는 지수 *E*를 인코딩한다.
+ n비트 비율 필드 ***frac*** = *f*<sub>*n - 1*</sub>...*f*<sub>*1*</sub>*f*<sub>*0*</sub>는 유효숫자 *M*을 인코딩한다.  

32비트 시스템에서는 s = 1, k = 8, n = 23비트를 가지며, double형의 64비트를 갖는 자료형에서는 s = 1, k = 11, n = 52비트를 갖는다.

쉽게 설명하면, 한 실수를 IEEE 부동소수점 표준에 맞게 변환한 다음, 각 필드에 맞게 인코딩하면 된다는 뜻이다.  

부동소수점으로 나타낼 수 있는 값을 크게 세 분류로 나눌 수 있다. 그 중 가장 일반적인 경우를 ***정규화 값***이라고 한다.

<br>

### - 정규화 값

정규화 값은 가장 일반적인 경우로, exp 비트 패턴이 모두 0이 아니며, 모두 1이 아닌 경우이다. 여기서 **지수부 필드**는 부호형 정수로 만들기 위해 ***Bias*** 를 사용하였다. Bias는 *Bias* = 2<sup>*k - 1*</sup> - 1 이며, 지수부의 음수 표현을 위해 사용된다.(단일정밀도에서 127, 이중정밀도에서 1023) 즉 지수부를 비부호형으로 계산한 다음, Bias를 빼주면 원하는 지수값을 얻을 수 있다는 것이다.

따라서 지수 값은 *E* = *e* - *Bias*이며, e는 비트 패턴 *e*<sub>*k - 1</sub> ... *e*<sub>*1*</sub> *e*<sub>*0*</sub> 을 가진다.  

**비율**필드 frac은 이진수 표시로 0.*f*<sub>*n - 1*</sub> ... *f*<sub>*1*</sub> *f*<sub>*0*</sub> 를 가지는 것으로 해석된다. **유효숫자** M = 1 + *f* 로 frac에 암시적으로 정수부분에 1이 있다고 본다. 이는 E를 조정해서 유효숫자 M이 항상 1 ≤ M < 2 범위를 갖도록 할 수 있기 때문에, 비트 한개를 무료로 얻어 정밀도를 높히기 위함이다.

<br>

### - 비정규화 값

비정규화 값은 지수 필드가 모두 0일때를 말한다. 이 경우 ***지수 값***은 *E* = 1 - *Bias* 이다. ***유효숫자*** M = *f* 로, 암시적으로 정수부분에 1이 아닌, 0이 있는 것이다.  

여기서 눈치가 빠른 사람들은 궁금할 것이다. 왜 지수 값이 -*Bias*가 아닌 1 - *Bias*를 사용했을까? 왜 유효숫자 정수 부분은 0인가?  

먼저 간단한 유효숫자에 대해 설명해주겠다. 기존 정규화 값으로는 0을 표현할 수가 없다. 따라서 0을 표현하기 위해 지수 필드가 모드 0인 매우 작은수의 경우 정수 부분을 0으로 설정하여 0을 표현할 수 있도록 하였다. 또한 비정규화 숫자들의 기능은 0.0에 매우 가까운 값들을 나타내기 위함이기 때문에 정수 부분을 0으로 설정한 것이다.  

그렇다면 지수 값은 왜 1 - *Bias*인가? 이는 비정규화 값에서 정규화 값으로 전환함에 있어 편리하기 때문이다. 아래 예시로 확인해보자.

`0 00000000 000000000000000000001` = 0.000000000000000000001 * 2<sup>-126</sup>  
`0 00000000 111111111111111111111` = 0.111111111111111111111 * 2<sup>-126</sup>
`0 00000001 000000000000000000000` = 1.000000000000000000000 * 2<sup>-126</sup>

위 2개 수는 비정규화 값이고, 맨 아래는 정규화 값이다. **비트 수준에서**, 위 2개 값을 더했을 때, 맨 아래 값이 나오면 비트 연산에도 추가적인 계산 없이 비트 덧셈만 진행하면 된다. 이는 매우 편리하기 때문에 이에 맞게 실제 값도 조정하고 싶을 것이다. 따라서 지수 값을 1 - *Bias*로 조정함으로써, 비정규화 값과 정규화 값 전환이 편리하도록 만든 것이다.

<br>

### - 특수 값

부동소수점의 마지막 범주는 지수 필드가 모두 1인 경우이다. 지수 필드가 모두 1이고, 비율 필드가 모두 0이면 결과값은 무한대를 나타낸다. 즉 *s* = 0 이면 +∞ , *s* = 1 이면 -∞ 를 의미한다. 또한 비율 필드가 모두 0이 아니면, 결과값은 *NaN* 으로, "not a number"를 의미한다. 이런 값들은 
∞ - ∞ 혹은 (-1)<sup>0.5</sup> 같은 연산의 결과로 반환된다. 이들은 초기화되지 않은 데이터를 표시할 때와 같이 일부 응용에서 유용할 수 있다.

아래 예제를 통해 부동소수점에 대해 정리해보자. 지수비트 *k* = 4, 비율비트 *n* = 3, *Bias* = 2<sup>4 - 1</sup> - 1 = 7 을 갖는 8비트 부동소수점 형식으로 나타낼 수 있는 수를 표로 정리하였다.

|설명|비트 표현|*E*|*M*|2<sup>*E*</sup>X*M*|십진수|
|---|---|---|---|---|---|---|
|0|0 0000 000|-6|0/8|0/512|0.0|
|가장 작은 양수|0 0000 001|-6|1/8|1/512|0.001953|
||0 0000 010|-6|2/8|2/512|0.003906|
|||. . .||||
|가장 큰 비정규화|0 0000 111|-6|7/8|7/512|0.013672|
|가장 작은 정규화|0 0001 000|-6|8/8|8/512|0.015625|
||0 0001 001|-6|9/8|9/512|0.017578|
|||. . .||||
||0 0110 111|-1|15/8|15/16|0.9375|
|1|0 0111 000|0|8/8|1|1.0|
||0 0111 001|0|9/8|9/8|1.125|
|||. . .||||
|가장 큰 정규화|0 1110 111|7|15/8|1920/8|240.0|
|무한대|0 1111 000|-|-|-|∞|
|*NaN*|0 1111 001|-|-|-|-|

정규화 값, 비정규화 값의 *Bias* 를 고려하며 값을 확인하다보면 어느새 부동소수점에 익숙해져 있을 것이다.

> 부동소수점은 제한된 범위와 정밀도를 갖기 때문에, 실제 값의 근사값으로 연산을 진행한다. 따라서 오차가 생길 수 있음을 항상 유의하여야한다.

<br>

### - 비트 확장 / 축소

float, double은 마찬가지로 확장되거나 축소될 수 있다. int, float, double 간의 타입 캐스팅이 일어났을 때, 어떤 변화가 일어나는지 확인해보자.

+ int에서 float로, 숫자는 오버플로우할 수 없지만, 근사될 수 있다.
+ int나 float에서 double로, 정확한 수치는 보존될 수 있다.(더 넓은 범위의 비트를 갖기 때문에 표현 가능한 값의 범위가 늘어나 정밀도가 더 크기 때문)
+ double에서 float로, 범위가 더 작아지기 때문에 오버플로우하여 +∞ 혹은 -∞ 가 될 수 있다. 그 이외의 경우 정밀도가 더 작아져 근사될 수 있다.
+ float나 double에서 int로, 값은 0 방향으로 근사될 것이다.(소수점 이하 버림)

<br>

이번 포스트에서는 정수와 실수의 표현 방법을 알아보았다. C에서 예상치 못한 결과나 버그를 마주칠때가 있는데, 위 내용을 잘 이해하면 그런 문제들을 해결하는데 도움이 될 것이다. 다음 포스트에서는 프로그램의 기계 수준의 표현에 대해 설명하겠다.